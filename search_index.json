[["index.html", "References Summary License", " References David DHaese Gepubliceerd op 2021-03-13 09:06:36Orchesella flavescens L., Motic SMZ171© 2020 David DHaese Summary AI Principles course of the AP University College at Antwerp, Belgium. The course is in Dutch. License The content of this project including its source code is licensed under the GNU Affero General Public v3.0 license. You are allowed to Under the conditions You are not allowed to Commercial use Disclose source Liability Distribution License and copyright notice Warranty Modification Network use is distribution Patent use Same license Private use State changes "],["inleiding-tot-de-cursus.html", "Hoofdstuk 1 Inleiding tot de cursus 1.1 In een notedop 1.2 Leerdoelen 1.3 Cursus vorm 1.4 Bekijken van deze Cursus 1.5 Licentie voor deze cursus 1.6 Verwijzen naar deze cursus", " Hoofdstuk 1 Inleiding tot de cursus 1.1 In een notedop In deze cursus zullen we het erg breed domein van artificiële intelligentie (AI) en machinaal leren (ML; eng: machine learning) aansnijden. Omdat de discipline zo breed is, kunnen onmogelijk alle topics aan bod komen. In plaats daarvan is er gekozen om eerst een brede basis te verschaffen rond de begrippen en principes die gemeenschappelijk zijn voor ML en AI om ons daarna specifiek te richten naar het toepassen van AI in een realistische context. We gaan leren om op basis van data en een eenvoudige opdracht zelfstandig een AI-analyse uit te voeren. Deze aangeleerde vaardigheid maakt van een doorsnee IT-er een beginnende data-ingenieur. Gaandeweg zullen we ons echter van bewust moeten maken dat deze vaardigheid ook een aantal verantwoordelijkheden met zich meebrengt. Het gaat dan voornamelijk om het toepassen van ethische AI. 1.2 Leerdoelen Hieronder, in Tabel 1.1, staan de leerdoelen opgesomd zoals ze vermeld staan in de ECTS fiches voor dit opleidingsonderdeel. In de cursus zal er naar deze leerdoelen verwezen worden met vermelding van de bijhorende code. Tabel 1.1: Leerdoelen voor deze cursus Code Omschrijving TI_LD577 Beheerst de kunst van data exploratie TI_LD578 Ontwikkelt zelfstandig een AI toepassing op basis van een probleemstelling TI_LD579 Rolt een ontwikkelde AI toepassing uit TI_LD580 Rapporteert op correcte wijze over de onzekerheden van een AI oplossing TI_LD581 Past de principes toe van Explainable AI TI_LD582 Beheerst minstens vijf verschillende ML-algoritmen TI_LD583 Past de regels rond privacy-bescherming en ethical AI toe TI_LD584 Gebruikt pipelines in een AI oplossing TI_LD585 Visualiseert complexe data op correcte en verhelderende wijze TI_LD586 Past het principe van ensemble learning toe TI_LD587 Configureert een ML algoritme op correcte wijze op basis van de documentatie TI_LD588 Bouwt een bibliotheek met meest frequent gebruikte functies 1.3 Cursus vorm Deze cursus is geschreven in een versie van Markdown. Markdown is een familie van zogenaamde opmaaktalen (eng: mark-up languages) die ervoor zorgen dat inhoud van het document in verscheidene formaten weergegeven kan worden: PDF, HTML, . Het loskoppelen van inhoud betekent enerzijds dat de auteur zich kan focusseren op de inhoud in plaats van de vorm. Anderzijds betekent het dat de lezer in staat is om de vorm van de uitvoer te bepalen, bijvoorbeeld, beter leesbaarheid, donkere achtergrond, . Voor meer technische documenten biedt Markdown nog veel belangrijkere voordelen. Het maakt het mogelijk om code in de ene of andere taal tussen de lyrische tekst te plaatsen en uit te voeren. Met de juiste IDE (Integrated Development Environment), betekent dit dat de auteur én de lezer in staat zijn om in meerdere programmeertalen tegelijkertijd te werken! Figuur 1.1: Werking van Markdown. De platte tekst (links) wordt omgezet naar een ander formaat (rechts; hier HTML) door een externe tool als Pandoc. Stijl-regels worden hier automatisch uitgevoerd maar de auteur heeft de mogelijkheid ook deze in detail te configureren. Naast het scheiden van vormgeving en inhoud (hetgeen een merkelijke efficiëntie verbetering met zich meebrengt) ondersteund R Markdown ook meertaligheid, i.e. meerdere programmeertalen in één document. Tussen een aantal talen is er zelfs wederzijdse uitwisseling mogelijk van de actieve variabelen (zie oranje markeringen met pijl). Het voorbeeld met de Mandelbrot fractaal is afkomstig van Li 2017, waarvan de GitHub repository een bondige beschrijving geeft van de Mandelbrot verzameling (eng: Mandelbrot set) met een test die de performantie-winst van Julia t.o.v. R onderzoekt. 1.4 Bekijken van deze Cursus Deze cursus kan je het best bekijken door gebruik te maken van je browser. Voor een betere ervaring zijn je de browser het best op volledig scherm. Er is een sneltoets om wisselen tussen gewoon en volledig-scherm modus (Chrome, Firefox: F11, Safari: Control +  + F). Heb je meerdere tabs open en vind je het vervelend navigeren in volledig-scherm-modus, is er voor Chrome een leuke extension: QuicKey.. 1.5 Licentie voor deze cursus De inhoud van deze cursus valt onder een GNU Affero General Public v3.0 licentie. Wat er toegelaten is en onder welke voorwaarden staat hieronder opgesomd (hover met je muis over de tabel voor meer info): Je mag Onder voorwaarde dat Je mag niet Commercieel gebruik Ontsluit bron Aansprakelijk stellen Verspreiden Licentie en copyright notice mee verspreiden Garantie Aanpassen Netwerk verspreiding Patenteren Zelfde licentie Privé gebruiken Bekendmaking wijzigingen 1.6 Verwijzen naar deze cursus Bibtex-formaat: @online{dhaese2020ai-principles, author = {DHaese, David}, title = AI-Principles, year = 2020, url = https://ddhaese.github.io/Course_AI-Principles/, note = \"[Online; accessed } APA-formaat: DHaese, D., 2020. AI Principles [WWW Document] [Online; accessed ]. URL https://ddhaese.github.io/Course_AI-Principles/ "],["leren-uit-data.html", "Hoofdstuk 2 Leren uit data 2.1 Het leerproces 2.2 De evolutie van het machinaal leren 2.3 Intelligentie 2.4 Het model 2.5 Doelfunctie 2.6 MNIST dataset 2.7 Het resultaat van MNIST analyse 2.8 Het MNIST model 2.9 Het leerproces voor begeleid ML 2.10 De onderdelen van een model 2.11 Hyperparameters 2.12 Het leeralgoritme 2.13 Model complexiteit 2.14 Comprimeren door middel van een ML model 2.15 Leren versus ontwerp 2.16 Leren versus onthouden en inferentie 2.17 Onbegeleid ML 2.18 Conditionering", " Hoofdstuk 2 Leren uit data 2.1 Het leerproces Leerdoel 2.1 Rapporteert op correcte wijze over de onzekerheden van een AI oplossing (TI_LD580). Leerdoel 2.2 Past de principes toe van Explainable AI| (TI_LD581). Machine learning (ML) is het vermogen van een algoritme om te leren uit data. In deze inleiding zullen we leren dat, hoewel dit een eenvoudige definitie lijkt, hier toch héél wat achter schuilt. Dus om deze definitie wat kracht bij te zetten, maken we hier meteen ons eerst kadertje voor: Stelling 2.1 Machine learning (ML) is het vermogen van een algoritme om te leren uit data. De term word ook ruimer geïnterpreteerd als de discipline die zich bezighoud met het creëren van zulke algoritmen. Laten we eens filosoferen over de term leren in deze stelling. Wat betekent het in feite om iets te leren? Prof. Abu-Mostafa, een gerenommeerde didacticus in deze discipline legt het in zijn boek Learning from data (Abu-Mostafa et al. 2012, p.1) ongeveer zo uit: Laat een foto aan een driejarige zien en vraag de kleuter of er een boom te zien is en je krijgt bijna zeker het juiste antwoord. Vraag nu aan een dertig-jarige persoon om de definitie van een boom te geven en je krijgt vermoedelijk een onduidelijk of toch onvolledig antwoord. Hoe komt dit? Een mens leert niet wat een boom is door de wiskundige beschrijving van een boom te memoriseren maar door het beeld te associëren met het woord en de klank en door gecorrigeerd te worden telkens wanneer we een fout maken. De fotos en tekeningen, de geur, het geritsel van de bladeren, de juf die boom zegt, de ouder die wijst, de vier letters op het schoolbord: dat zijn de data. Het verzamelen van al die data en classificeren ervan onder de noemer boom gebeurt door onze hersenen en dat proces noemen we leren. Laten we dit schematisch voorstellen: Figuur 2.1: Het centraal zenuwstelsel van een mens kan leren uit data. Het concept boom wordt hier met een gedachten-wolk voorgesteld en komt overeen met een model van de realiteit. Het eindpunt van het leerproces is het model. In het voorbeeld van de boom is dit model het concept of mentaal beeld van een boom dat in onze hersenen achterblijft ook wanneer we niet naar een boom kijken. Dit model is een vereenvoudigde versie van de werkelijkheid. Het bevat zeker niet alle wiskundige verhoudingen noch alle biologische details van één boom, laat staan van alle bomen op aarde. Toch slagen de meesten onder ons een onderscheid te maken tussen een boom en een niet-boom. Stelling 2.2 Het eindpunt van het leerproces is een model dat een vereenvoudigde versie van de werkelijkheid kan weergeven Persoonlijkheid 2.1 (Yaser Abu-Mostafa) Yaser Abu-Mostafa is een professor Computer Science aan de California Institute of Technology. Hij is beroemd geworden voor zijn memorabele online cursussen rond ML. Zier hier for meer details. 2.2 De evolutie van het machinaal leren De mens is al eeuwenlang bezig met het bouwen van automaten (zogenaamde automata). Een prachtig voorbeeld hiervan is de geautomatisserde tekenaar-schrijver die de Zwitserse mechanieker Henri Maillardet bouwde rond 1800: Hierbij ging het meestal om voorgeprogrammeerde robotten zonder enige vorm van intelligentie. Eén van de eerste vormen van meer intelligente robotten waren de machina speculatrix van Grey Walters: Ondertussen weten we dat er zelf-rijdende wagens, zelf-vliegende drones en zelf-varende boten bestaan: 2.3 Intelligentie ML is een onderdeel van artificiële intelligentie (AI). Er bestaan vele definities voor deze term, maar het VLEVA (VlaamsEuropees Verbindingsagentschap) maakt een duidelijk onderscheid. Zij spreken van ML wanneer patronen in data, al dan niet rechtstreeks afkomstig van sensoren, worden omgezet naar een model, zoals eerder reeds aangehaald. AI gaat een stap verder. Hier wordt er, op basis van het model en nieuwe data, werkelijk ook actie ondernomen en keuzes gemaakt. Bij ML wordt deze fase nog aan de mens overgelaten. Dus zelf-rijdende wagens behoren duidelijk tot het domein van AI, terwijl een applicatie die op basis van een paar fluittonen een melodie kan herkennen eerder thuishoort onder ML. Andere voorbeelden van ML toepassingen zijn het voorspellen van de financiële markten, beeldherkenning, geautomatiseerde medische diagnoses, enz Dit onderscheid blijft natuurlijk erg artificieel en in sommige gevallen zal deze classificatie niet opgaan. Maar we kunnen wel zeggen: Stelling 2.3 De huidige vormen van artifiële intelligentie baseren bijna uitsluitend op machinaal aangeleerde modellen Dus geen AI zonder ML. Maar wat betekent intelligentie in feite? Volgens Wikipedia bestaat intelligentie uit meerdere capaciteiten zoals (logisch) redeneren, begrijpen, zelfbewustzijn, aanleren, emotionele intelligentie, plannen, creatief zijn, kritisch denken en probleemoplossing. Voorlopig ligt de focus bij ML voornamelijk op het aanleren al wordt ook op alle andere aspecten heel wat onderzoek verricht. We moeten voorlopig dus best nog bescheiden blijven met het gebruik van de term artificiële intelligentie. Het is ook heel belangrijk om te realiseren dat er vormen van intelligentie bestaan die erg verschillen van de menselijke intelligentie. Uiteraard wist je dat vele andere dieren aspecten van intelligentie kunnen bezitten. maar wist je ook dat er bij planten vormen van intelligentie werden vastgesteld en dit maakt het des te merkwaardiger gezien zij niet over een centraal zenuwstelsel beschikken. 2.4 Het model Laten we beginnen met het eindproduct van ML. We zagen dat het eindpunt van ML het model is. In tegenstelling tot wat deze term in bijvoorbeeld database management betekent, kan je het model het best beschouwen als een functie \\(\\hat{f}\\), ook wel de finale hypothese genoemd (final hypothesis; Abu-Mostafa et al. 2012): \\[\\hat{f}: \\mathcal{X} \\to \\mathcal{Y}\\] Proberen we nu ons boom-herkenning oefening te vertalen van de menselijke wereld naar de ML wereld, dan bestaat het model uit een functie die een antwoord biedt op de vraag: Wordt op deze digitale foto een boom afgebeeld? Nadat de digitale afbeelding een zekere voorbereiding (eng: pre-processing) doorlopen heeft, zal het bestaan uit mogelijk een set van variabelen zoals voorgesteld in figuur 2.2. Figuur 2.2: Als we de oefening om een boom te herkennen uit figuur 2.1 vertalen naar de machinale wereld krijgen we data van waaruit het algoritme een model heeft aangeleerd. Het model kunnen we hier voorstellen door middel van een functie \\(\\hat{f}\\). Het hoedje op de \\(f\\) dient om aan te geven dat het om een geschatte waarde gaat. \\(\\mathcal{X}\\) is hier de input en bestaat in dit voorbeeld uit allerhande variabelen die betrekking hebben op gedigitaliseerde afbeeldingen. Bijvoorbeeld, de variabele Dominante kleur stelt de meest frequente kleur-groep die op de afbeelding voorkomt. \\(\\mathcal{Y}\\) is de output, de variabele die het antwoord bevat op de vraag of er al dan niet een boom wordt afgebeeld waarbij de witte en zwarte bollen overeenkomen met ja/neen of true/false. In python zal het model dus ongeveer de volgende vereenvoudigde vorm kunnen aannemen: def model(x): # Some code goes here return y en het equivalent in R is als volgt: model &lt;- function(x_test){ # Some code goes here return(y_predicted) } 2.5 Doelfunctie Het is je misschien opgevallen dat het symbool voor het model een hoedje draagt: \\(\\hat{f}\\). Dat is geen toeval. Dat wil in feite zeggen dat het om een geschatte functie gaat. Daartegenover staat de werkelijke functie \\(f\\), de zogenaamde doelfunctie (Abu-Mostafa et al. 2012). Het is belangrijk om te beseffen dat de doelfunctie \\(f\\) in de meeste gevallen onbekend blijft! Tijdens simulaties of binnen de wetenschappelijke disciplines gebeurt het wel eens dat de \\(f\\) gekend is, maar in de meeste gevallen waar een datawetenschapper mee te maken krijgt is dat niet het geval. Het doel is uiteraard om te proberen om met het model \\(\\hat{f}\\) de doelfunctie \\(f\\) zo goed mogelijk te benaderen, en dat valt niet mee als \\(f\\) onbekend is. Er zijn verscheidene opties om deze benadering tot een succes te maken. Één van deze benaderingen, diegene die we in dit hoofdstuk toepassen, noemt men het begeleid leren (eng: supervised learning). Stelling 2.4 Het doel van begeleid ML is om een model \\(\\hat{f}\\) te vinden dat de werkelijke doelfunctie \\(f\\), die meestal onbekend blijft, zo goed mogelijk tracht te benaderen. 2.6 MNIST dataset We gaan nu trachten de eerste ideeën rond ML te vertalen naar de praktijk. Om dit mogelijk te maken, wordt er een nieuwe probleem met bijhorende dataset voorgesteld. Behalve het begrip boom zullen de meeste peuters ook één of ander schrift aangeleerd krijgen. Hoewel gedrukte letters tegenwoordig natuurlijk domineren, wordt er nog steeds het handschrift aangeleerd (figuur 2.3). Behalve mensen is het natuurlijk interessant mocht een computer ook handgeschreven teksten kunnen lezen zodat bijvoorbeeld historische werken gedigitaliseerd kunnen worden. Figuur 2.3: Het handgeschreven alfabet zoals voorgesteld met de schrijfmethode DHaese (geen familie; bron). Om dit mogelijk te maken kan men een model creëren dat in staat is om de handgeschreven karakters te herkennen. Het Amerikaanse Modified National Institute of Standards and Technology biedt een dataset aan met fotos van handgeschreven letters en cijfers in allerlei varianten. Om de zaak te vereenvoudigen gaan we ons in dit voorbeeld beperken tot de handgeschreven cijfers (figuur 2.4). De cijfers (in de training set) zijn afkomstige van 250 schrijvers, zowel werknemers van de Census Bureau als studenten van het hoger middelbaar onderwijs. Figuur 2.4: Subset van de MNIST dataset met afbeeldingen van handgeschreven cijfers. Elke geschreven karakter is een afzonderlijke afbeelding van \\(28\\times28\\) pixels. Elke afbeeldingen werd uitgeknipt uit een groter gescand document met geschreven tekst, gecentreerd en teruggebracht naar een grootte van \\(28\\times28\\). Oefening 2.1 (MNIST probleem) Kijk eens goed naar de variaties voor de cijfers in Figuur 2.4. Valt je iets op? Zou er een probleem kunnen ontstaan indien je deze dataset bijvoorbeeld zou willen inzetten voor het leren herkennen van de handgeschreven notities van AP-studenten? Geef je antwoord op Digitap. Elke afbeelding in de MNIST dataset wordt voorgesteld als een \\(28\\times28\\)-matrix. Elke element van deze matrix stelt een grijswaarde voor van een pixel uit de afbeelding. Stel dat de afbeeldingen in de RGB kleurruimte zouden zijn opgeslagen, dan zou er voor elke pixel niet één maar drie waarden beschikbaar worden gemaakt. Figuur 2.5: Het 300ste cijfer het de MNIST training-set. Elke instantie van de input dataset (eng: instance) wordt dus voorgesteld door een \\(1\\times784\\)-vector en de ganse input dataset kan worden voorgesteld als een \\(n\\times784\\)-matrix, waarbij \\(n=60\\,000\\) de grootte van de (training-) dataset is zoals beschikbaar gemaakt door MNIST. 2.7 Het resultaat van MNIST analyse We gaan later in detail onderzoeken hoe we precies de beeldherkenning kunnen uitvoeren. Nu nemen we eerst een kortere weg naar het resultaat. Kijk even terug naar figuur 2.2 en herinner je dat het resultaat van een ML process een model was dat wiskundig als functie \\(\\hat{f}\\) kan worden voorgesteld. Schematisch zal onze analyse er nu uitzien zoals voorgesteld in figuur 2.6. Merk hier wel op dat de cijfer-varianten in werkelijkheid vervat zitten in een platte matrix is met dimensies \\(60\\,000\\times784\\), een matrix dus met méér dan 47 miljoen zwevende kommagetallen (eng: floating point). Figuur 2.6: De schematische weergave van het leerproces voor het herkennen van handgeschreven cijfers uit de MNIST dataset. Stellen we het model voor met de Python functie model, kan kunnen we dit aanroepen met één of meerdere afbeeldingen van handgeschreven cijfers: y_prd_300 = model(x_trn[299:300]) Hier roepen we het model aan met de 300ste afbeelding uit de training-set (zie figuur 2.5), hier voorgesteld als x_trn[299:300]. Het resultaat van deze oproep wordt in variabele y_prd_300 bewaard. In wiskundige termen schrijven we \\(\\hat{y}_{300}\\), waarbij het hoedje aangeeft dat het niet de werkelijk \\(y\\)-waarde is maar de geschatte of voorspelde \\(y\\)-waarde. In theorie zou men verwachten dat de inhoud y_prd_300 gelijk is aan 6. Het is zeker mogelijk om model zo te schrijven dat dit inderdaad het geval is, maar meestal wordt er de voorkeur aan gegeven om naast de eigenlijke voorspelling ook een maat van de betrouwbaarheid van deze schatting mee te laten geven. In dit geval ziet y_prd_300 er zo uit: [[1.3147994e-08 4.3827520e-12 5.0856454e-07 1.3127689e-09 4.5237027e-07 5.3989115e-09 9.9999893e-01 5.3377733e-09 1.6693608e-07 3.1370115e-09]] Dit is iets heel anders dan 6, wat is hier gaande? In feite bestaat het model uit de kans dat de aangeleverde afbeelding overeenkomt met één van de 10 mogelijke uitkomsten, namelijk de cijfers 0 tot en met 9: Cijfer \\(p(instantie=cijfer|beeld)\\) 0 1.3147994e-08 1 4.3827520e-12 2 5.0856454e-07 3 1.3127689e-09 4 4.5237027e-07 5 5.3989115e-09 6 9.9999893e-01 7 5.3377733e-09 8 1.6693608e-07 9 3.1370115e-09 We zien nu ogenblikkelijk dat \\(p(\\hat{y}_{300}=6|x_{300}) = 99.99\\%\\). Dus in plaats dat het model ons het cijfer 6 teruggeeft, geeft het een schatting van de kansverdeling over alle mogelijke uitkomsten \\(P(cijfer|beeld)\\). Het is dan aan de datawetenschapper om, in samenspraak met anderen binnen het team, de drempelwaarde (eng: threshold) te bepalen tussen wat voldoende zeker is en wat niet. Stel dat we in dit geval de drempelwaarde \\(h_\\tau=0.99=99\\%\\) aannemen, dan vertaalt dit inderdaad naar het (in dit geval correcte) antwoord \\(\\hat{y}_{300}=\\hat{f}(x_{300}, h_\\tau=0.99)=6\\). 2.8 Het MNIST model We weten nog steeds niet hoe het model voor het herkennen van de MNIST cijfers eruit ziet, laat staan hoe het tot stand is gekomen. Laten we eerst eens proberen na te gaan hoe het model er van binnen uitziet. In dit geval bestaat het model uit een complex netwerk van gewichten \\(\\mathbf{\\theta}\\) die in lagen verdeeld zijn (zie figuur 2.7). Figuur 2.7: Schematische voorstelling van het MNIST model. Elke grijswaarde (uiterst links) in een afbeelding is verbonden met allerlei noden van de eerste laag in het netwerk (groot blauw raster links) en elke node uit de eerste laag is verbonden met de noden uit de tweede laag (kleiner blauw raster rechts). De oranje balk uiterst rechts stelt het antwoord voor, de kansverdeling over alle mogelijke uitkomsten, zoals uitgelegd in vorige paragraaf. We kunnen de gewichten uit het model opvragen: &lt;tf.Variable &#39;dense_4/kernel:0&#39; shape=(784, 128) dtype=float32, numpy= array([[ 0.08104221, -0.03245814, 0.05782456, ..., 0.01628028, 0.01527335, -0.0621725 ], [-0.02486849, -0.05942973, -0.05000503, ..., 0.05511766, 0.01111819, -0.01273195], ..., [-0.03103521, 0.04082336, -0.03615728, ..., -0.07942228, 0.05170608, -0.04771789], [-0.08011643, -0.02025594, 0.07396395, ..., -0.04995897, 0.04946151, 0.0736245 ]], dtype=float32)&gt; [[2]] &lt;tf.Variable &#39;dense_4/bias:0&#39; shape=(128,) dtype=float32, numpy= array([ 0.1288752 , 0.12100432, -0.00982326, 0.1232934 , 0.02084712, 0.01321915, -0.01993161, 0.0420486 , -0.08715703, 0.06092769, ..., 0.11226735, -0.06676487, -0.03609373, -0.05284352, -0.07687864, 0.16832131, 0.08192852, -0.07676063, 0.03645244, -0.04636759, 0.05661207, 0.13083224, 0.02666049], dtype=float32)&gt; In het totaal bestaat deze specifieke versie van het MNIST model dus uit \\(784\\times128 + 128 = 100\\,480\\) gewichten. Deze gewichten worden op een nog nader te begrijpen manier gebruikt om \\(\\hat{y}\\) te berekenen uit \\(x\\). Het model zou er dus ongeveer als volgt kunnen uitzien in Python: def model(x, tau = 0.99): weights_0 = array([[ 0.08104221, -0.03245814, ..., 0.04946151, 0.0736245 ]] weights_1 = array([ 0.1288752, 0.12100432, ..., 0.13083224, 0.02666049] y_dist = predict(x, weights_0, weights_1) y_hat_prob = max(y_dist) y_hat = y_dist.index(y_hat_prob) if(y_hat_prob &lt; tau): y_hat = None return y_hat In ons voorbeeld zou, indien x overeenkomt met \\(x_{300}\\) uit 2.5, y_dist overeenkomen met \\(P(\\hat{y}_{300}|x_{300})\\), y_hat_prob met \\(99.999893\\%\\) en y_hat met \\(6\\). Indien de berekende distributie 10 waarden zou bevatten die allen kleiner zijn dan \\(h_\\tau\\) (tau in de code hierboven), zou dit model aangeven dat er te weinig zekerheid is over welk cijfer de afbeelding moet voorstellen door de waarde None terug te geven. Stelling 2.5 Het is volstrekt normaal dat een ML model in sommige situaties geen voorspelling kan maken. 2.9 Het leerproces voor begeleid ML Zoals gezegd gaan we nog niet volledig in detail onderzoeken hoe een ML model tot stand komt, maar laten we toch al trachten het ML proces te schematisch reconstrueren, specifiek voor wanneer het gaat om begeleid leren. Wat weten we tot nu toe? We weten dat we vertrekken met training data \\(\\left(\\mathcal{X}_{trn},\\mathcal{Y}_{trn}\\right)\\) en eindigen met een model \\(\\hat{f}\\). We weten ook al dat het model een functie is die test data \\(\\mathcal{X}_{tst}\\) als invoer heeft en een voorspelling (eng: prediction) \\(\\hat{y}\\) als uitvoer (zie Figuur 2.8). Figuur 2.8: Eerste overzicht van het leerproces voor begeleid ML. Ronde vormen staan voor acties of functies, rechthoekige vormen geven objecten weer. Met andere woorden, het proces voor ML kan gecodeerd worden als \\(\\hat{f}=\\ell(\\mathcal{X}, \\mathcal{Y})\\). \\(trn\\) staat voor training, \\(tst\\) voor test. leren: eng. learning, training. voorspellen: eng. to predict, inference. 2.10 De onderdelen van een model Het model is dus een functie met daarin de gewichten \\(\\mathbf{\\theta}\\) alsook de nodige logica om de invoer op de juiste manier te bewerken met de gewichten. Dit laatste wordt in tekstboeken vaak over het hoofd gezien omdat het in de praktijk vaak neerkomt op een eenvoudige matrix vermenigvuldiging. Hier wordt ervoor gekozen om dit een beetje explicieter te maken. In het MNIST model uit vorige paragraaf zien we nog een derde element, het argument \\(h_\\tau\\) (tau in code). Dit is een hyperparameter. Hyperparameters die gekoppeld zijn aan een model dienen vaak, net als bij \\(h_\\tau\\), om een grenswaarde te bepalen tussen wat een goede voorspelling is en wat niet. We zullen in volgende paragraaf zien dat er ook hyperparameters gekoppeld kunnen worden aan het leeralgoritme, waar ze gewoonlijk een heel andere rol gaan spelen. Stelling 2.6 Het model dat het resultaat is van begeleid machinaal leren bestaat uit minstens 2 onderdelen: de gewichten \\(\\mathbf{\\theta}\\) de modellogica maar is vaak pas bruikbaar mits het definiëren van nog een derde onderdeel: de hyperparameters \\(\\mathbf{h}_f\\) 2.11 Hyperparameters Hyperparameters worden zo genoemd om ze duidelijk te onderscheiden van gewichten, die in de literatuur ook vaak parameters worden genoemd. Het onderscheid is belangrijk omdat hyperparameters het proces zelf beïnvloeden (e.g. waar moet je de lijn trekken, hoeveel getallen na de komma moet genereren, ) terwijl conventionele parameters het onderwerp zijn van de wiskundige bewerking waarmee invoer wordt omgezet naar een voorspelling. Stelling 2.7 Hyperparameters geven aan hoe een proces moet verlopen. Parameters dienen als invoer voor een functie. De manier waarop parameters tot stand komen worden bepaald door het leeralgoritme (zie volgende §). Hyperparameters, daarentegen worden door de datawetenschapper gekozen ofwel in een afzonderlijk proces automatisch geoptimaliseerd. De keuze voor de waarde van een hyperparameter zoals \\(h_\\tau\\) kan gemaakt worden door de datawetenschapper op basis van ervaring ofwel omdat het door de omgeving wordt opgelegd. Laten we twee voorbeelden bekijken die aangeven hoe de omgeving een drempelwaarde kan opleggen. Voorbeeld 2.1 Stel, er wordt de datawetenschapper gevraagd om een algoritme te ontwikkelen om afbeeldingen van katten en honden (en telkens exact één kat of één hond) te onderscheiden, gewoon voor het plezier. Stel dat het algoritme slechts één waarde uitvoert, namelijk de probabiliteit \\(p_{kat}\\) dat de afbeelding een kat laat zien. De probabiliteit dat het een hond is (\\(p_{niet kat}\\)), kan hieruit berekend worden met de formule \\(p_{niet kat}=1-p_{kat}\\). Een logische drempelwaarde op deze probabiliteiten is \\(0.5\\). Vanaf dat \\(p_{kat}\\) zakt onder deze waarde, gaan we ervan uit dat het om een hond gaat. Voorbeeld 2.2 De datawetenschapper wordt nu gevraagd om een algoritme te ontwikkelen om op basis van tal van bloedwaarden van een patiënt te bepalen of deze ziek is of niet. Het algoritme voert weer slechts één waarde uit, ditmaal de kans om ziek te zijn \\(p_{ziek}\\). De drempelwaarde mag nu niet meer zo maar op \\(0.5\\) worden geplaatst. Waarom niet? ML algoritmen maken fouten maar niet alle fouten zijn even erg. Het foutief aanduiden van een gezonde persoon als ziek is niet zo erg als het foutief aanduiden van een zieke patiënt als gezond. Maar hoe weet de datawetenschapper dan welke drempelwaarde er gekozen moet worden? Nu komt het: in dit geval mag de datawetenschapper in geen geval een drempelwaarde zelf bepalen. De arsten die de opdracht geven dragen de verantwoordelijkheid om de ideale drempelwaarde te bepalen Stelling 2.8 Hyperparameters moeten vaak door andere mensen dan de datawetenschapper worden bepaald (ook als ze dat niet willen). 2.12 Het leeralgoritme Om van de training data naar het model te gaan heb je een leeralgoritme \\(\\ell\\) nodig. Voorbeelden hiervan zijn support vector machines (SVM), neuraal netwerken (NN), naïef Bayes algoritmen (NB), enzovoort Er zijn wel honderden algoritmen waaruit een datawetenschapper kan kiezen, en voor elk algoritme zijn er gewoonlijk oneindig veel mogelijke instellingen1 (lett.). We begrijpen uit vorige paragraaf dat parameters en hyperparameters verschillend zijn maar puur wiskundig beschouwd, dienen ze allebei gewoon als invoer voor de ene of ander functie. Noteren we de hyperparameters bij het leeralgoritme nu als \\(\\mathbf{h}_\\ell\\), dan krijgen we het volgende: \\[\\hat{f}=\\ell\\left(\\{\\mathcal{X}, \\mathcal{Y}\\}, \\mathbf{h}_\\ell\\right)\\] Hier staat: het ML model wordt, in het geval van begeleid ML, gevormd door een leeralgoritme dat zowel data als invoer heeft (\\(\\{\\mathcal{X}, \\mathcal{Y}\\}\\)) als hyperparameters die het leerproces kunnen beïnvloeden. Wat is dan de rol van de hyperparameters die op het leeralgoritme inwerken? Zonder nu al te veel in gaan op het intern mechanisme van de leeralgoritmen, is één van de veel voorkomende functies van \\(\\mathbf{h}_\\ell\\) om te bepalen hoe snel het leeralgoritme te werk moet gaan. Ik wil hier nog even benadrukken dat het resultaat van het leeralgoritme moet bestaan uit een set van parameters én een functie-logica. Deze functie-logica ligt voor een bepaald leeralgoritme vast. Bijvoorbeeld, voor een logistische regressie, bestaat deze logica uit een logit-transformatie en een matrix vermenigvuldiging. Deze logica plus de parameters \\(\\mathbf{\\theta}\\) vormen samen het model. De hyperparameters die op het model inwerken worden, zoals uitgelegd in vorige §, meestal achteraf bepaald door de datawetenschapper of opgelegd door de omgeving. 2.13 Model complexiteit Merk op dat een ML model niet zo complex hoeft te zijn als dit MNIST model. Het kan best dat een model bestaat uit slecht een handvol parameters. Laten we een voorbeeld in beschouwing nemen. Voorbeeld 2.3 Een zeer bekende oefen-dataset is de iris dataset waarin afmetingen van de kelkbladen en kroonbladen van drie soorten irissen werden opgenomen. Bron: Szczecinkowaty 2007, Mayfield 2005, Mayfield 2007. Stel dat het doel is om de drie sterk gelijkende bloemensoorten te onderscheiden op basis van slechts 2 variabelen, namelijk de lengte van het kroonblad \\(x_p\\) en de lengte van het kelkblad \\(x_s\\). Veronderstel verder dat het model reeds getraind werd. Het model zou bijvoorbeeld kunnen afhangen van slechts 3 parameters die op \\(x_s\\) en \\(x_p\\) inwerken, bijvoorbeeld: \\(\\theta_1 = 2.5\\), \\(\\theta_2 = 1.2\\) en \\(\\theta_3=0.3\\). De logica van het model zou er dan bijvoorbeeld als volgt kunnen uitzien: \\[species=\\begin{cases}\\text{setosa als }x_p&lt;\\theta_1\\\\\\text{versicolor als }x_s&gt;\\theta_2p+\\theta_3\\\\\\text{virginica anders}\\end{cases}\\] In dit geval kan de model-logica als volgt gecodeerd worden (Python): def model(x): if x.p &lt; 2.5: return &quot;setosa&quot; if x.s &gt; 1.2 * x.p + .3: return &quot;versicolor&quot; return &quot;virginica&quot; Deze versie van het iris-model met slechts 3 gewichten (parameters!) is wel erg eenvoudig maar er staan ML modellen in productie die niet veel complexer zijn en toch hun werk doen. Complexiteit is trouwens geen goede maatstaf voor de kwaliteit van een model. Soms eisen de vragende partij of andere belanghebbenden in het AI project nadrukkelijk een zo eenvoudig mogelijk model zodat het begrijpbaar en transparant blijft. Aan de andere kant bestaan er ook modellen die nog véél complexer zijn dan het MNIST model met honderden miljarden gewichten (\\(J &gt; 10^{11}\\); Shazeer et al. 2017)! Stelling 2.9 Model complexiteit is geen goede maatstaf voor de kwaliteit van een model. 2.14 Comprimeren door middel van een ML model Uit de vorige paragraaf leren we dat modellen zeer eenvoudig of zeer complex kunnen zijn. Meestal bevat het model inclusief de gewichten weliswaar véél minder informatie dan de oorspronkelijk data waarop getraind werd. In deze gevallen kan je het model beschouwen als een vereenvoudigde voorstelling van de werkelijkheid of nog als een geavanceerde zip-functie, hetzij eentje die niet volmaakt is (eng: lossless). Het zou ons te ver leiden om de compressie-factor (eng: compression ratio) te berekenen op basis van de Informatietheorie, maar misschien kunnen we een grove schatting maken van de compressie-factor voor ons MNIST-model (zie Voorbeeld 2.4). Voorbeeld 2.4 De training set bestaat uit 60 000 afbeeldingen van 28 × 28 pixels. Met de grijswaarden in enkelprecisievariant (eng: single precision) van de zwevendekomma getallen komt de grootte van de training set op: \\[60\\,000\\times28\\times28\\times32\\approx1.5\\cdot10^9 bits\\] Daartegenover bestond het MNIST-model uit \\(100\\,480\\) gewichten: \\[100\\,480\\times32\\approx3.2\\cdot10^6 bits\\] Dit brengt ons op een compressie-factor van: \\[\\frac{1.5\\cdot10^9 bits}{3.2\\cdot10^6 bits} &gt; 450\\] Oefening 2.2 (Iris compressie) Probeer nu zelf ook eens de compressiefactor in te schatten voor het iris-model uit Voorbeeld 2.3. Zei opties meerkeuzevraag op Digitap. 2.15 Leren versus ontwerp We hebben al heel wat woorden vuil gemaakt om te begrijpen wat ML eigenlijk inhoud. Laten we nu even stilstaan bij wat ML niet is. Om te beginnen is ML niet ontwerpen. Wat is het verschil? Ook hier is het gemakkelijkste om het verschil aan te tonen aan de hand van twee voorbeelden. Voorbeeld 2.5 (Ontwerp-benadering verkoopsautomaat probleem) De probleemstelling is als volgt: Maak een verkoopautomaat die op basis van de massa en de diameter de 4 verschillende Indiase muntstukken (0.5, 1, 2 en 5 Rs) zo goed mogelijk kan onderscheiden. Oplossing via ontwerp: Zoek naar de specificaties die gebruikt worden tijdens het ontwerpen van de munstukken. Op de webpagina van Takashi Shimazaki vind je een samenvatting: Waarde (Rs) Massa (\\(g\\)) Diameter (\\(mm\\)) 0.5 3.79 22.0 1 4.85 25.0 2 5.62 27.0 5 6.00 23.0 We veronderstellen verder een standaardafwijking op de metingen van \\(0.09g\\) en \\(0.1 mm\\) en een fouttolerantie van maximaal 0.1%. Op basis van deze gegevens stellen we een grafiek op en beslissen we met de hand waar de grenswaarden worden gedefiniëerd: Voorbeeld 2.6 (ML-benadering van het verkoopsautomaat probleem) Oplossing via ML: zoek naar data met werkelijke metingen van de massas en diameters van de verscheidene Indiase munstukken. Bij gebrek aan zulke data zit er niets anders op dan een random steekproef te nemen van de munstukken en ze zelf te meten (of door iemand betrouwbaar te laten meten). Hier is het resultaat van de metingen: verkoopautomaat-ml De kleuren stellen het resultaat voor van een clusteralgoritme (k-means), dit is trouwens een type algoritme dat onbegeleid tewerk gaat en verschilt dus fundamenteel van het begeleid ML dat we tot hiertoe bespraken. Uit deze data lijkt het of de spreiding veel groter is dan aangenomen in vorig Voorbeeld. Daardoor maakt het model hier vermodelijk een aantal fouten in de classificatie. Het model weet hier ook niet welke cluster overeenkomt met bijvoorbeeld 2 roepie. De enige input, naast de diameters en de massas van de muntstukken is dat er 4 clusters in het totaal moeten zijn. De data in dit voorbeeld werden gesimuleerd, zie hieronder voor meer detail. De grafiek voor ontwerp benadering kan je genereren met de onderstaande R code: library(plotrix) coins &lt;- fread(&quot; Waarde\\tMassa\\tDiameter 0.5\\t3.79\\t22.0 1\\t4.85\\t25.0 2\\t5.62\\t27.0 5\\t6.00\\t23.0&quot;) plot(0, type = &quot;n&quot;, xlim = c(21, 28), ylim = c(3, 7), xlab = &quot;Diameter&quot;, ylab = &quot;Massa&quot;) alpha &lt;- .001 dummy &lt;- coins[, draw.ellipse(Diameter, Massa, qnorm(1 - alpha, 0, 0.1), qnorm(1 - alpha, 0, 0.09))] segments(c(25, 22.5, 25.2), c(3, 4.7, 6), c(21, 26.5, 28), c(5.5, 7, 3), lty = 3) dummy &lt;- coins[, text(Diameter, Massa, Waarde)] Hieronder vind je de code terug voor de ML-benadering uit Voorbeeld 2.6. Merk op dat ik hier, omdat er niet direct data voorhanden was, de data zelf heb gesimuleerd. library(MASS) set.seed(42) # Generating data copula &lt;- function(lab, n, rho, mu1, mu2, sd1, sd2){ mu &lt;- c(mu1,mu2) sigma &lt;- matrix(c(sd1 ^ 2, sd1 * sd2 * rho, sd1 * sd2 * rho, sd2 ^ 2),2) mvrnorm(n, mu, sigma) %&gt;% as.data.table %&gt;% set_names(c(&quot;Diameter&quot;, &quot;Mass&quot;)) %&gt;% cbind(Label = lab) } coins_meas &lt;- coins[1, copula(&quot;0.5&quot;, 500, .3, Diameter, Massa, .8, .5)] %&gt;% rbind(coins[2, copula(&quot;0.5&quot;, 500, .3, Diameter, Massa, .8, .5)]) %&gt;% rbind(coins[3, copula(&quot;0.5&quot;, 500, .3, Diameter, Massa, .8, .5)]) %&gt;% rbind(coins[4, copula(&quot;0.5&quot;, 500, .3, Diameter, Massa, .8, .5)]) # Analyzing data model &lt;- kmeans(coins_meas, centers = 4, iter.max = 1000) plot(coins_meas$Diameter, coins_meas$Mass, xlab = &quot;Diameter&quot;, ylab = &quot;Massa&quot;, pch = 19, col = model$cluster, cex = .6) text(model$centers[,&quot;Diameter&quot;], model$centers[,&quot;Mass&quot;], LETTERS[1:4]) 2.16 Leren versus onthouden en inferentie De moeilijkste te onderscheiden begrippen in de wereld van ML zijn leren versus inferentie. Dit probleem komt trouwens deels overeen met het onderscheid tussen respectievelijk ML en regressie. Zich de moeite getroosten om een model te ontwikkelen heeft alleen maar nut indien het ook achteraf gebruikt zal worden om voorspellingen mee te doen. Met andere woorden om dingen te ontdekken die men (t.t.z. de computer) nog niet wist. Laten we onderstaand voorbeeld onderzoeken om te begrijpen wat het precies betekent om niets nieuw te leren. Voorbeeld 2.7 (MT cars relatie) De Motor Trend Car Road Tests dataset bevat 10 standaard eigenschappen voor de motoren van 32 automerken zoals verbruik, cilinderinhoud en dergelijke. Deze data zijn net als iris data een waarde geworden in de wereld van de statistiek. De data werd oorspronkelijk verzameld uit het Motor Trend US magazine van 1974 (zie Henderson and Velleman 1981). Geef ?mtcars in R om meer te weten te komen. Stel nu dat er een theorie bestaat die de cilinderinhoud \\(c\\) in verband brengt met de massa \\(w\\) van de wagen door middel van een variant van de zogenaamde hill-functie: \\[c=\\theta_1+\\frac{\\theta_2-(w-\\theta_3)^2}{\\theta_4^2+(w-\\theta_3)^2}\\] De onderzoeker zal trachten deze vraag te beantwoorden. Hij voert een niet-lineare regressie analyse uit. Hierbij zal een zogenaamd optimalisatie-algoritme de 4 parameters wijzigen totdat de functie die zo ontstaat zo goed mogelijk overeenkomt met de aangeleverde dataset. De onderstaande clip brengt dit proces tot leven: cars-regressie Naarmate dat de optimalisatie vordert (zie Nelder 1965), verkleint de afwijking tussen voorspelde curve met de datapunten, zoals te zien is aan de zogenaamde Root mean squared Error (RMSE). Op het einde van de optimlisatie, bij een RMSE van 52.527, komt het algoritme tot stilstand met de volgende parameter-waarden: \\[\\theta_1=78, \\theta_2=517.47, \\theta_3=1.87, \\theta_4=2.10\\] Wat het Voorbeeld 2.7 laat zien is gebaseerd op een vooraf bepaalde model-logica. Van dit model mogen wel de parameters maar niet de complexiteit noch de formule gewijzigd worden. Er kan inderdaad een ideale parameter-set gevonden kan worden die bij deze 32 datapunten past. Maar wat als dezelfde opdrachtgever nu tegen de onderzoeker zegt dat die zich vergist had. Het zou beter zijn om te de puntenwolk te beschrijven door middel van een polynoom van de vijfde graad. De onderzoeker zet zich eraan en schrijft de volgende R code: rmse &lt;- function(y, x){ sqrt(mean((y - x) ^ 2)) } model &lt;- lm(disp ~ poly(wt, 5), data = mtcars) rmse(model$fitted.values, mtcars$disp) Het resultaat is nu een RMSE van 52.492, beter dan het vorige resultaat, alleen ziet de resulterende curve er nu een beetje vreemder uit: Het probleem is natuurlijk dat hoe hoger de graad van de polynoom, hoe beter de fit zal zijn (is een wiskundige zekerheid) maar ook hoe lelijker de curve zal worden: Wat hier aan het gebeuren is noemt met overfit. Een polynoom met zulke hoge graad is veel te complex voor het onderliggend patroon. We voelen dit ergens wel aan. Voordat ML populair was, zou een onderzoeker op het gevoel afgaan om de graad van de polynoom te bepalen. In ML wordt de complexiteit niet op voorhand opgegeven en zoekt het leeralgoritme zelf uit hoe complex het model mag worden alvorens er overfit optreedt. Kunnen we dat overfitten ook formaliseren of zelfs bewijzen? Het antwoord is ja en ja. Het eerste (het formaliseren) zou ons te ver leiden, maar voor de geïnteresseerden raad ik aan om de term VC dimension op te zoeken, genoemd naar twee grondleggers van de ML theorie: Vladimir Vapnik en Alexey Chervonenkis en het boek (of online lezingen) van Yaser Abu-Mostafa (zie (thm: abumostafa)) te bekijken (Abu-Mostafa et al. 2012). Het tweede aspect (het bewijzen) is eenvoudiger. We moeten gewoon op zoek gaan naar nieuwe data: We zien nu het gevolg van overfitting. Wanneer we het model blootstellen aan nieuwe data zien we dat het eenvoudige model (polynoom van graad 5) veel beter presteert dan het complexere model (polynoom van graad 7). En dat is het hem nu net allemaal om te doen! Leren om voorspellingen te maken, niet leren om de training dataset nauwkeurig te beschrijven, want dat is gewoon onthouden of hoogstens comprimeren zoals we eerder zagen. Daarom is ML veel interessanter dan regressieanalyse. Je kan stellen dat regressie (zoals de naam het eigenlijk al aangeeft) gaat over achterom kijken, terwijl ML gaat over naar de toekomst kijken. 2.17 Onbegeleid ML Tot hier toe werd er voornamelijk gesproken rond begeleid ML (eng: supervised machine learning). Er zijn nog minstens twee andere vormen die binnen sommige disciplines erg populair zijn. In Voorbeeld 2.6 werd wel gesproken van clusters, en dat is een voorbeeld van onbegeleid ML (eng: unsupervised machine learning of self-organization). Het verschil tussen begeleid en onbegeleid is het gebruik van de uitkomsten (\\(y\\)) als invoer voor het leeralgoritme. Stelling 2.10 Bij begeleid ML wordt het leeralgoritme getraind op invoer data (\\(\\mathbf{x}\\); de onafhankelijke variabelen) die paarsgewijs gekoppeld zijn met uitvoer data (\\(\\mathbf{y}\\); de afhankelijke variabele of uitkomst). Het algoritme leert de verbanden tussen \\(\\mathbf{x}\\) en \\(\\mathbf{y}\\). Bij onbegeleid ML is er geen sprake van een uitkomst en leert het algoritme gewoon patronen te herkennen in de invoer data. Figuur 2.9: Vergelijking tussen het proces van begeleid L en het proces van onbegeleid leren. Welke van beide moet je nu gebruiken? Heel simpel: als je een betrouwbare uitkomst in je bezit hebt, dan kies je best begeleid ML, omdat deze altijd beter zal presteren. Heb je geen uitkomsten of twijfel je aan de authenticiteit of accuraatheid, dan kan je (tijdelijk) overstappen op onbegeleid leren. Binnen onbegeleid leren, zijn er twee families die veel gebruikt worden. Eentje is de principale componenten analyse (PCA; eng: principal component analysis), de ander is cluster analyse (eng: cluster analysis). In beide gevallen is het resultaat een categorisatie van de instanties (zoals bijvoorbeeld een clustering) of een set van associaties (zoals bijvoorbeeld aanbevelingen, eng: customer recommendations). Stelling 2.11 Een onbegeleid ML algoritme vertelt je of twee instanties bij elkaar horen (grote kans op associatie, zelfde cluster, ) of niet. Laten we de discussie van onbegeleid ML afsluiten met een voorbeeld: Voorbeeld 2.8 Stel, een klant wil een geautomatiseerd systeem ontwikkelen om de scherpte meten van microtoommessen. De klant hoopt dit te kunnen doen a.d.h.v. microscopische opnamen van de snede van het mes, waarvan hieronder een voorbeeld: Het doel is om de oppervlakte te bepalen van de fellere horizontale lijn (de messnede), maar om dit te kunnen doen moet er een duidelijk onderscheid worden gemaakt tussen fellere pixels en donkere pixels. M.a.w., elke pixel moet gecategoriseerd worden als messnede of achtergrond. Een begeleid ML aanpak zou inhouden dat een mens heel wat afbeeldingen manueel beoordeeld en dat er een classificatie algoritme gevoed zou worden met deze uitkomst data. Alleen is dat hier niet erg praktisch en bovendien erg onbetrouwbaar. Vandaar de keuze voor onbegeleid leren. Elke pixel in bovenstaande afbeelding bevat een R, een G en een B waarde. Het doel is om de afbeelding om te zetten naar een grijswaarde afbeelding, maar dan wel met de optimale gewichten voor de afzonderlijke R, G en B kleur-kanalen zodat er een maximaal contrast ontstaat. We zien immers dat de snede van het mes groen-achtig en niet wit is en we kunnen dus vermoeden dat de drie kleuren een verschillend gewicht gaan krijgen bij het zoeken naar het hoogste mogelijk contrast. Hieronder wordt de code getoond (imports en een aantal helperfuncties weggelaten; zie broncode voor details): predict_pca &lt;- function(x, n) { x$x[, 1:n] %*% t(x$rotation[, 1:n]) %&gt;% scale(scale = FALSE, center = -1 * x$center) %&gt;% as.data.table } contrast &lt;- function(img) { img %&gt;% img_to_dt %&gt;% prcomp( ~ R + G + B, data = .) %&gt;% predict_pca(1) %&gt;% dt_to_img(dim(img)) %&gt;% grayscale %&gt;% normalize } par(mar = rep(0, 4)) img &lt;- &quot;img/Microtome_knife_5.0_5.0_0097.JPG&quot; %&gt;% load.image %&gt;% contrast %&gt;% plot(axes = FALSE) De code leest als volgt: Laad de afbeelding Microtome_knife_5.0_5.0_0097.JPG en in de contrast functie: zet je het beeld eerst om naar een data.table met de helper-functie img_to_dt (niet getoond). Start daarna de principale componenten analyse op met de ingebakken stats::prcomp functie. Geef hierbij mee dat de drie kleur-kanalen moeten gebruikt wordt om het grootste contrast te vinden. Neem het resultaat van de analyse en neem de eerste component (de combinatie van R, G, en B-waarden die het meeste variantie verklaart) en voer daarmee de omgekeerde bewerking uit met de predict-pca functie. Het resultaat is dat er een iets beter drempel-waarde (eng: threshold) gevonden kan woorden waarme de messnede geïdentificeerd kan worden: Demo PCA results Het probleem met onbegeleid ML is dat je nooit zeker weet dat je echt iets geleerd hebt. Bijvoorbeeld, indien een onbegeleid model een nieuwe instantie onderbrengt in een welbepaalde cluster, hoe weet je dan of het juist is of fout? Daarom is die term onbegeleid leren mogelijk nogal verwarrend en is het vaak veiliger om gewoon te spreken van clustering (bijv. k-means) of eigen-decompositie (bijv PCA.). 2.18 Conditionering Er is nog een derde soort ML, namelijk de conditionering (eng: reinforcement learning). In plaats van een afhankelijke variabele, wordt de uitkomst aangeleverd als een functie die, gegeven een bepaalde input zal teruggeven of de nieuwe situatie een verbetering is of niet. Het grootste verschil met de twee eerder besproken vormen van ML is dat er voor conditionering geen nood is aan historische data. In plaats daarvan is er een soort online- data generatie systeem voorhanden. Het is dus in zeker zin supervised, maar toch weer een beetje anders. Stelling 2.12 Voor conditionering (reinforcement learning) heb je geen historische data nodig. Enkel een tolk die in staat is een actie van een agent te beoordelen. Conditionering kent toepassingen in erg veel verschillende disciplines waaronder de statistiek, maar ook de speltheorie, meet- en regeltechniek, operationeel onderzoek, de informatietheorie, enzovoort. Het werkt zo. Een software-agent (eng: agent) krijgt de keuze uit een aantal acties (eng: actions) die het kan uitvoeren op een omgeving (eng: environment). De omgeving vertaalt de gekozen actie naar enerzijds een toestand-wijziging (eng: state change) en anderzijds een beloning (eng: reward). Figuur 2.10: Overzicht proces voor conditionering. We komen later meer uitgebreid terug op conditionering, maar nu houden we het bij een minimalistische implementatie van een soort conditionering, genaamd Q-learning, dit maal in Python. Het voorbeeld is afkomstig van de blog The Beginner Programmer van Mic en hetgeen op zijn beurt gebaseerd is op een Q-learning handleiding op de Mnemosyne_Studio blog van John McCullock. Voorbeeld 2.9 Gegeven onderstaande plattegrond van een huis met vijf kamers, vind het korst mogelijke pad naar buiten als je je in kamer 2 bevindt. Figuur 2.11: De plattegrond. (bron) De belonging kan voorgesteld worden als een matrix: Figuur 2.12: De beloning-matrix ( bron) import numpy as np reward = np.matrix( [[-1,-1,-1,-1, 0, -1], [ -1,-1,-1, 0,-1,100], [ -1,-1,-1, 0,-1, -1], [ -1, 0, 0,-1, 0, -1], [ -1, 0, 0,-1,-1,100], [ -1, 0,-1,-1, 0,100]]) We maken nu een matrix die het geheugen voorstelt van de tolk. Hierin zal de tolk zijn eerdere ervaringen in opslaan. Dit geheugen stelt de toestand (eng: state) voor waarin de agent zich bevindt. Zoals je ziet weet de agent initieel helemaal niets. memory = np.matrix(np.zeros([6, 6])) In andere situaties kan het aantal toestanden waarin een agent zich kan bevinden helemaal niet gedefinieerd zijn en dan moet de matrix dynamisch worden opgesteld. Het opvullen van de toestand-matrix gebeurt volgens de onderstaande transitie regel (eng: transition rule): \\[ Q(toestand, actie)=R(toestand, actie)+h_\\gamma\\cdot max(Q(volgende\\,toestand,\\,alle\\,acties)) \\] We hebben nu een functie die, gegeven een bepaalde toestand, de set van mogelijke volgende toestanden teruggeeft (available_actions) en een tweede die gegeven de mogelijke toestanden er een willekeurige toestand uitkiest (sample_next_action). def available_actions(state): current_state_row = reward[state,] av_act = np.where(current_state_row &gt;= 0)[1] return av_act def sample_next_action(available_actions_range): next_action = int(np.random.choice(available_act,1)) return next_action Ten slotte hebben we een update-functie, de instap-functie a.h.w. van het leeralgoritme, die het geheugen (de toestand-matrix) vernieuwd: def update(current_state, action, gamma): max_index = np.where(memory[action,] == np.max(memory[action,]))[1] if max_index.shape[0] &gt; 1: max_index = int(np.random.choice(max_index, size = 1)) else: max_index = int(max_index) max_value = memory[action, max_index] memory[current_state, action] = reward[current_state, action] +\\ gamma * max_value We initialiseren nu het spel met de leersnelheid \\(h_\\gamma\\) en de initiële kamer (2) en de doel-ruimte (buiten, ruimte 5) en voeren de eerste update uit: gamma = 0.8 initial_state = 2 end_state = 5 Nu begint het trainen (10 000 iteraties): for i in range(10000): current_state = np.random.randint(0, int(memory.shape[0])) available_act = available_actions(current_state) action = sample_next_action(available_act) update(current_state, action, gamma) De toestand-matrix er nu zo uit: model &lt;- as.matrix(100 * py$memory / max(py$memory)) dimnames(model) &lt;- list(start = 0:5, stop = 0:5) model Nu testen we het model met een begintoestand van 2 en een eindtoestand van 5: current_state = initial_state steps = [current_state] while current_state != end_state: next_step_index = np.where( \\ memory[current_state,] == np.max(memory[current_state,]))[1] if next_step_index.shape[0] &gt; 1: next_step_index = int(np.random.choice(next_step_index, size = 1)) else: next_step_index = int(next_step_index) steps.append(next_step_index) current_state = next_step_index Het aangeleerd pad kan als volgt worden opgeroepen: py$steps %&gt;% paste(&quot;Ruimte &quot;, ., collapse = &quot; &gt; &quot;) Onder instellingen wordt hier onder andere een combinatie van hyperparameter-waarden verstaan. Omdat deze hyperparameters meestal continue variabelen zijn, maakt dit dat er letterlijk oneindig veel instellingen mogelijk zijn. Bovendien bestaan er voor elke leeralgoritme vaak talrijke varianten, elke met hun eigen voor- en nadelen. "],["data.html", "Hoofdstuk 3 Data 3.1 Data voor ML 3.2 Wat is data 3.3 Soorten data 3.4 Externe databronnen 3.5 Data Genereren 3.6 De analyse dataset 3.7 Soorten variabelen 3.8 (Eng) Nominal-Scale Data 3.9 (Eng) Dummy Variables 3.10 (Eng) Ordinal-Scale Data 3.11 (Eng) Circular-Scale 3.12 (Eng) Censoring 3.13 Tijd en ruimte 3.14 Toegang tot data 3.15 Het codeboek", " Hoofdstuk 3 Data 3.1 Data voor ML Leeralgoritmen gebruiken data om er een model uit te destilleren. Als er iets fout gaat, dan heeft dit vaak te maken met de staat waarin de data zich bevinden of de manier waarop er met de data wordt omgesprongen. Stelling 3.1 When it comes to ML, garbage in, garbage out (GIGO). De datawetenschapper streeft ernaar om de data die hij of zij te zien krijgt zo goed mogelijk te begrijpen. Wiskundig gezien is dat misschien niet zo belangrijk, maar het gaat hier over enerzijds het maken van de juiste keuzes en anderzijds voor de ethische overwegingen. Als je van plan bent om uitspraken te doen op basis van data, ben je ook verantwoordelijk voor het opbouwen van een grondig begrip van wat de data voor staat. Figuur 3.1: The gossip (ned. De roddel) van Norman Rockwell. Opmerking Als datawetenschapper heb je, indien de data betrouwbaar is en je voldoende integer bent om je van alle vooroordelen en taboes te ontdoen, toegang tot de ultieme waarheid. Ben je er klaar voor? 3.2 Wat is data Bij dit principe moeten we tegenwoordig niet erg lang stilstaan. Het is ondertussen voor de meeste mensen duidelijk dat overal waar je kijkt er data zijn. Alles wat je online doet maar ook alles wat je offline doet kan tot data worden omgevormd. Om als invoer te kunnen dienen voor een leeralgoritme, moeten de data in de eerste plaats natuurlijk beschikbaar zijn. En daar wringt het eerste schoentje al. Want beschikbaar betekent niet alleen dat je er toegang tot hebt, maar ook dat de data zich in het juiste formaat bevinden om te kunnen gebruiken door het leeralgoritme. 3.3 Soorten data Ook hier moeten we niet te lang bij blijven stilstaan. We bekijken wel een aantal vaak gebruikte termen. Interne data: Private data die behoren tot een organisatie. Externe data: Publieke data of private data van een andere organisatie Ongestructureerde data: Data die niet in een platte tabel-structuur kan worden weergegeven. Als het gekozen leeralgoritme hier niet mee overweg kan, moet je eerst features extraheren en zelf een platte tabel maken (eng: melting data) Metadata: Is data over data zoals tijdstip van opname, gebeurtenissen uit logboek, enz 3.4 Externe databronnen Veel gegevens worden intern bij organisaties bewaard in afzonderlijke, speciaal daarvoor voorziene databanken, bestanden of (zeker als het om historische gegevens gaat) de fysische tegenhangers zoals rekenbladen, werkboeken, documenten, archieven, . Vaak zijn er echter nog andere bronnen zoals audit-rapporten, usage-statistieken rond het gebruik van websites, logbestanden, videobeelden,  waar men niet onmiddellijk aan denkt. Binnen een bedrijfs-context is het net belangrijk om nieuwe databronnen aan te boren, bronnen waar de concurrentie niet eerder aan dacht. Hieronder een collage van een aantal potentiële interessante bronnen van data op het internet (naast de meest vanzelfsprekende zoals sociale media e.d.). Het gaat hier om generieke bronnen met data over meerdere domeinen. Academictorrents Amazon Web Services public datasets Brits open data platform Canadese open data site Common Crawl DataQuest Data World Europese Open data portaal FiveThirtyEight Forbes Gapminder Google Trends, Scholar, Patents, Google Dataset Search lab,  Kaggle Reddit Socrata Standaard datasets UCI Machine Learning Repository US Census Bureau US Open data portal Quandl Quantopian Wunderground enzovoort Hierboven worden een aantal databronnen opgesomd, maar het vergt vaak wel wat meer speurwerk om de ideal dataset te vinden. We gaan hier even een fictief voorbeeld aanhalen van hoe zo een zoektocht zou kunnen verlopen. Voorbeeld 3.1 Op zoek naar data (hypothetisch): je bent op zoek naar een gratis beschikbare data die een voorspellende waarde heeft voor het transportsnelheid van goederen over de Westerschelde. Je denkt dat windsnelheid misschien een impact kan hebben op de vaarsnelheid. Dit zou je zoektocht naar geschikte data bijvoorbeeld kunnen zijn: Je zoekt eerst naar een website die historische windsterkte vrijgeeft, liefst via API Je vind wel een aantal bronnen maar geen daarvan zijn én gratis én in staat om historische data op te halen Dan lees je ergens dat golfslag misschien een betere voorspellende waarde heeft Je zoekt op Google naar Wave Measurement en je komt dit wetenschappelijk artikel tegen In dat artikel blijken ze exact te doen wat je naar op zoek bent Daarom zoek je in dat artikel naar de Methods sectie om te achterhalen waar de auteurs hun data vandaan hebben (een wetenschappelijk artikel moet per definitie reproduceerbaar zijn dus moet het zijn bronnen altijd vermelden) Je vind dat ze de data van de organisatie NOAA hebben en je geeft het in op Google Op de website van de NOAA ontdek je dat ze de gegevens publiek ter beschikking stellen Er zijn data voor België beschikbaar, maar de frequentie waarmee ze beschikbaar worden gemaakt is toch teleurstellend Je realiseert je plots dat er misschien Belgische sites zijn die ook hun gegevens delen Je komt op de website van het Meetnet Vlaamse Banken en daar vind je, na inloggen, exact de data die je nodig hebt 3.5 Data Genereren Natuurlijk is er de optie om zelf data te genereren. In principe is dat iets dat typisch in het domein van de wetenschap valt omdat hierbij strikte deontologische regels te volgen zijn. De regels hebben er eigenlijk allemaal mee te maken dat de waarnemer zeker is (en dat ook kan aantonen) dat de waarnemingen betrouwbaar, accuraat, precies, ethisch verantwoord en relevant zijn. Dit is een niet te onderschatten taak en er is heel wat ervaring nodig om dit te kunnen bereiken. De correcte manier om dat te doen valt buiten het bereik van deze cursus maar geïnteresseerde lezers kunnen hiermee beginnen: Carey, S. S. (2011). A beginners guide to scientific method. Cengage Learning. 3.6 De analyse dataset De data kan allerlei vormen aannemen maar de leeralgoritme kunnen niet zomaar overweg met al die verschillende vormen. Vaak wil de datawetenschapper de data eerst integreren tot een enkel bestand of data-stroom met een platte tabel-structuur, dit noem men de analyse dataset. Stelling 3.2 Een leeralgoritme vereist meestal een analyse-dataset met een platte structuur. Dit betekent één tabel met één instantie per rij en één variabele per kolom. Figuur 3.2: De onderdelen van een dataset met platte structuur. 3.7 Soorten variabelen Het gaat hier over de data type van de variabele, bijvoorbeeld of het gaat over een getal of over tekst. Dit lijkt sterk op de verschillende data types die men in een programmeertalen tegenkomt (integer, string, ). Maar die overeenkomst is maar oppervlakkig. Binnen de statistiek is men verplicht om meer data types te onderscheiden die niet hun gelijke kennen binnen de IT. Laten we beginnen met de meest voorkomende data types in een grafiek te zetten: Figuur 3.3: Schematische visualisaties voor een aantal veel voorkomende data types Let op de labels op elke grafieken. ze geven telkens een realistisch scenario weer. Je kan deze enkelvoudige data types indelen volgens drie dimensies: Numeriek vs ordinaal vs nominaal: Met numerieke data kan je berekeningen maken, met ordinale gegevens kan je enkel ongelijkheid testen en met nominale gegevens kan je noch berekenen noch ongelijkheid testen Continu vs discreet: Bij een continue variabele kan je tussen twee willekeurig gekozen waarden oneindig veel andere waarden plaatsen. Bij een discrete variabele kan dat niet. Continue variabelen worden verder onderscheiden van op basis van de meetschaal. Bij een intervalschaal is er geen betekenisvol nulpunt (zoals bij temperatuur in graden Celcius) bij een getal met ratioschaal is dat wél het geval. Circulair vs lineair: Bij circulaire data is de as op zichzelf teruggeplooid om een cirkel te vormen. 3.8 (Eng) Nominal-Scale Data Whenever the data consist of categories, typically, we deal with so-called nominal-scale data. Examples are department, blood type, country, . Whenever there are only two categories, we speak of binary data (true/false, yes/no, success/failure, .). 3.9 (Eng) Dummy Variables Whenever we encounter a categorical feature, we may have to consider to create a set of dummy variables out of a single categorical variable so as to support statistical analysis in general and ML using a specific learner in particular: Figuur 3.4: Demonstration of the use of dummy variables. 3.10 (Eng) Ordinal-Scale Data In some cases, the categories in categorical data have some natural ordering such as is the case for ranking or scoring measures (e.g. good, medium, bad). Coding such a variable into a discrete numerical one is not very good from a statistical point of view (because then you assume a ratio scale which may not be realistic) but sometimes understandable from the practical point of view, especially if, for your particular problem, finding an appropriate learner can be hard. There is also the possibility to treat the ordinal-scale variable as a categorical one (and e.g. creating a set of dummy variables) but be aware that you lose information along the way. The same is true for other forms of discretizations, by the way. Opmerking One can always convert a variable with a rich data type to one with poor data type. This can benefit practicality be always means losing information. 3.11 (Eng) Circular-Scale Whenever there is no maximum or minimum value for a scale, it is said to be circular-scaled. Examples of such measurements are time of day, day of week, wind direction, bearing, . This type of scale can be super-imposed on other scale types and can be both discrete and continuous. For example, direction measured relative to e.g. the magnetic north is a interval-scaled continuous circular measure and the hour of the day follows a discrete circular scale. Mind that circular scale data is very hard to work with as even simple operations such as a mean requires special attention: Figuur 3.5: Circular scale data requires special attention. 3.12 (Eng) Censoring Sometimes data is according to a truncated scale. For example, in clinical data sets you frequently encounter situations where as patient is said to survive for at least x years after the treatment, indicated as &gt;x (e.g. &gt;12 years). For such a truncation we call the data right-censored. Similarly lab measurements are frequently reported to be below a certain limit without knowing the exact number such as &lt;1.03 mmol/L HDL, this is called a left-censored datum. In case we have censoring at both ends of the scale, we speak of interval censoring (e.g. 2 &lt; x &lt; 5 births per day). It remains important to try to understand the reason of the censoring. It could be that the measurement was not sufficiently accurate or maybe it was done accurately but afterwards categorized (placed into bins) during some preprocessing step. In case you need to deal with censoring there is a limited number of statistical tools to your disposal. One is the use of tobit regression. 3.13 Tijd en ruimte Data is een spiegel voor allerlei informatie uit de reële wereld. Toch zijn er twee grootheden die eruit steken. Het gaat om de twee dimensies tijd en ruimte. Andere variabelen zijn vaak secundair aan deze dimensies. Voorbeelden zijn het voorspellen van de toekomstige verkoopcijfers of de verspreiding van een virus tijdens een pandemie. Laten we naar een bekende (maar gedateerde) dataset kijken van de farmareus Johnson &amp; Johnson: plot (JohnsonJohnson, main = &quot;Kwartaalcijfers J&amp;J&quot;) Het gaat om de kwartaalcijfers van 1960 to 1980. Deze dataset wordt vaak in educatieve werken rond tijdsreeks-analyses gebruikt om het effect van een multiplicatieve seizoensafhankelijke trend (eng: seasonality) weer te geven. Multiplicatief betekent hier gewoon dat het seizoenseffect afhangt van de grootte van de waarde. We voelen meteen aan dat deze tijdsreeksen van een heel andere soort data zijn dan de eerder aangehaalde data. Dat heeft te maken met het feit dat een punt op dit lijndiagram niet onafhankelijk is van een ander punt op dezelfde lijn. We spreken van autocorrelatie. In het algemeen, wanneer men onderzoek doet naar de evolutie van gegevens in de loop van de tijd, spreekt van van trend analyse. Hetzelfde kunnen we nu doen voor ruimte. Onderstaande figuur laat zien hoe we bijvoorbeeld aantallen kunnen uitdrukken over een ruimtelijke dimensie (met toestemming van Hermans 2019). # From https://github.com/mhermans/thematic-maps-r # Thanks to Maarten Hermans # install.packages(&quot;BelgiumMaps.StatBel&quot;, repos = &quot;http://www.datatailor.be/rcube&quot;, type = &quot;source&quot;) library(BelgiumMaps.StatBel) library(sf) library(tmap) data(BE_ADMIN_MUNTY) munip_map &lt;- st_as_sf(BE_ADMIN_MUNTY) src &lt;- paste0( &quot;https://raw.githubusercontent.com/mhermans/&quot;, &quot;thematic-maps-r/master/data/muni_typology.csv&quot;) munip_data &lt;- read.csv(src) munip &lt;- merge(munip_map, munip_data, by.x = &quot;CD_MUNTY_REFNIS&quot;, by.y = &quot;gemeente_nis_code&quot;) qtm(munip, fill = &quot;hoofdcluster_lbl&quot;, fill.title = &quot;&quot;) Ook bij ruimtelijke variabelen merken we een autocorrelatie op, waarbij de waarde op één plaats niet onafhankelijk is van de waarde op een naburige plaats. 3.14 Toegang tot data Je moet natuurlijk zien toegang te krijgen tot de data. Als datawetenschapper moet je alvorens een opdracht te aanvaarden eerst dé vraag stellen. Net als Jerry Maguire moet je de vraag durven stellen: Show me the data! Soms zijn de data publiek toegankelijk en is het gewoon een kwestie om tijd te nemen om door de data te lopen, i.e. aan exploratie te doen. Soms moeten de data nog verzameld worden. Dan wil de datawetenschapper ook inspraak hebben in het verzamelen en de eventuele verwerking van de gegevens. Het kan natuurlijk voorkomen dat men enkel toegang verschaft nadat er een akkoord is om een ML project op te starten. Het advies is hier om er alles aan te doen om toch op zijn minst een glimp te kunnen opvangen van de data. Soms zijn de data te koop en krijg je geen data te zien alvorens je betaalt? Wel, indien je op voorhand geen toegang krijgt tot zelfs een klein representatief deel van de gegevensberg of -stroom, dan kan je nog altijd een samenvatting opvragen, het zogenaamd codeboek. Je kan de opdrachtgever belagen met vragen: Hoeveel tabellen zijn er? Voor elke tabel, hoeveel rijen en kolommen zijn er? Hoeveel data ontbreekt er? Wat is het formaat van de gegevens? enz 3.15 Het codeboek Het eerste contact met een dataset verloopt normaal gezien via het codeboek. Het codeboek bevat de sleutel tot het begrijpen van de data zonder de data zelf te moeten inkijken. Hier is een voorbeeld in JSON formaat: { &quot;title&quot;: &quot;Occupancy Detection Data Set&quot;, &quot;description&quot;: &quot;Experimental data used for binary classification (room occupancy) from Temperature, Humidity, Light and CO2. Ground-truth occupancy was obtained from time stamped pictures that were taken every minute.&quot;, &quot;data_set_type&quot;: [&quot;Multivariate&quot;, &quot;Time-Series&quot;], &quot;instances_count&quot;: 20560, &quot;publication_date&quot;: &quot;2016-02-29&quot;, &quot;origin_contact_email&quot;: &quot;Luis Candanedo &lt;luismiguel.candanedoibarra@umons.ac.be&gt;&quot;, &quot;outcome&quot;: &quot;Occupancy&quot;, &quot;outcome_type&quot;: &quot;Binary&quot;, &quot;feature_type&quot;: &quot;Real&quot;, &quot;feature_count&quot;: 7, &quot;variable_descriptions&quot;: { &quot;Time&quot;: &quot;Time of measurement&quot;, &quot;Temperature&quot;: &quot;Temperature in Celsius&quot;, &quot;Humidity&quot;: &quot;Relative air humidity in %&quot;, &quot;Light&quot;: &quot;Light intensity in Lux&quot;, &quot;CO2&quot;: &quot;CO2 concentration in ppm&quot;, &quot;Humidity_Ratio&quot;: &quot;Derived quantity from temperature and relative humidity, in kg[water-vapor]/kg[air]&quot;, &quot;Occupancy&quot;: &quot;0 or 1, 0 for not occupied, 1 for occupied status&quot; }, &quot;references&quot;: [ &quot;Candanedo, L. M., &amp; Feldheim, V. (2016). Accurate occupancy detection of an office room from light, temperature, humidity and CO2 measurements using statistical learning models. Energy and Buildings, 112, 28-39.&quot; ] } Dit voorbeeld van een codeboek is oorspronkelijk afkomstig van de UCI repository. Het is daarna nog hier en daar aangepast om als voorbeeld te kunnen dienen. Dat het in JSON formaat staat is niet onbelangrijk. Soms gaat het over complexe datasets met duizenden kolommen. Zo bestaat de learning databank, onderliggend aan onze Digitap omgeving, uit 4992 kolommen! Als je dan op zoek moet naar de exacte eenheid waarin een variabele beschreven staat of wat een variabele nu weer precies betekent is dat niet werkbaar. Uit de het bovenstaande codeboek lezen we dat het gaat over sensordata in een ruimte om te proberen voorspellen of er iemand in de ruimte aanwezig is of niet. We zien dat er 20 560 instanties zijn, waarbij op elke instantie gegevens verzameld worden van de verscheidene sensoren. Dat is zeker niet slecht. Om aan statistiek te doen (ML behoort voor 100% tot de statistiek) moet je voldoende gegevens hebben en als de patronen in de gegevens maar amper boven de ruis uitsteken, dan heb je méér data nodig. Daaronder lezen we dat de data publiek zijn gemaakt op 2016-02-29. Dit strookt met wat we later zouden ontdekken, namelijk dat de datums in de dataset vóór deze datum liggen (2015-02-02 14:19, ). Het wetenschappelijk artikel werd gepubliceerd in 2016, dus dat kan ook kloppen. Door op deze wijze een soort reconstructie te doen van de feiten kan een datawetenschapper soms achterhalen of de data nog wel hedendaags zijn of dat er bijvoorbeeld iets niet pluis is. Dit kom je niet vaak tegen, maar idealiter is het goed om, zoals hier, over de contactgegevens te beschikken voor in geval er toch nog vragen opduiken. Er wordt dus ook verwezen naar het wetenschappelijk artikel en daar vind je normaal gezien een detail-beschrijving van de methodologie. Zo vind je daar terug dat één van de gebruikte sensoren een vochtigheid- en temperatuur-sensor is van het type DHT22, informatie die van pas kan komen indien deze data anomalieën zouden vertonen. Tenslotte vinden we natuurlijk in het codeboek ook een beschrijving van de variabelen. Deze beschrijving omvat idealiter de volgende elementen: een beschrijving van de variabele de eventuele eenheden waarmee de grootheden geassocieerd dienen te worden of de variabele het gevolg is van een rechtstreekst meting (bijv. output van een sensor) of achteraf berekend werd uit andere variabelen zoals hier het geval is voor Humidity_Ratio een overzicht van de waarde ruimte, de set van mogelijke waarden die de variabele kan aannemen (\\(\\mathbb{R}\\), \\(\\mathbb{Z}^+\\), {0, 1}, datum-veld met resolutie van 1 minuut, ) "],["data-exploratie.html", "Hoofdstuk 4 Data exploratie 4.1 Principes van data exploratie 4.2 Stappen in data exploratie 4.3 Voorbeeld data exploratie 4.4 Univariate verdelingen 4.5 Correlatie tussen twee variabelen", " Hoofdstuk 4 Data exploratie Leerdoel 4.1 Past de juiste principes toe tijdens het exploreren, hanteren en opkuisen van data (EA_LD758). Leerdoel 4.2 Beeld complexe data uit door middel van hedendaagse visualisatie tools (EA_LD761). 4.1 Principes van data exploratie Exploratieve Data Analyse (eng: Exploratory Data Analysis; EDA) zal de datawetenschapper helpen om twee hoofddoelen te bereiken Stelling 4.1 De twee hoofddoelen die de datawetenschapper voor ogen heeft tijden het exploreren van data zijn Begrijpen van de data én van processen die tot de data geleid hebben Controleren dat de dataset in zijn geheel maar ook elke variabele afzonderlijk aan een aantal eisen voldoet De datawetenschapper wil tijdens het controleren van een variabele de volgende eigenschappen onderzoeken: D uidelijkheid Kan de betekenis van de variabele achterhaald worden? Zo niet, dan is het vaak veiliger de variabele niet te gebruiken. I nformatief Is de informatie inhoud voldoende groot. Bijvoorbeeld, is het erg repetitieve data, dan is het misschien niet erg bruikbaar. Wordt mede bepaald door voorradigheid (zie hieronder). P rivacy Loop je met de betrokken variabele het risico om de privacy van de eindgebruiker te schenden volgens de opgestelde Privacy Impact Assessment (PIA) of volgens de Vlaamse of Federale wetgeving, dan mag je deze variabele simpelweg niet ontsluiten. K waliteit Zijn er technische redenen om de data niet te kunnen gebruiken? Zijn de data moeilijk om te onttrekken (bij bijv. vrije tekst), is er onvoldoende resolutie (bij metingen of afbeeldingen), gaat het om een té complex data type (bijv. circulaire),  E thiek Het trainen met tendentieuze data leidt tot een tendentieus algoritme. Om dit te voorkomen, laat je best variabelen weg die mogelijk wel een zeker voorspellend vermogen hebben en privacy-gewijs perfect toelaatbaar zijn, maar die de vooringenomenheid uit het verleden zou bevestigen. V oorradig Ontbreekt er méér dan ±30% van de waarden voor een bepaalde variabele (NULL, NA, \"\", -1, ), dan kunnen vele leeralgortimen de data niet gebruiken. E chtheid Het kan voorkomen dat de data weinig betrouwbaar lijken in de zin dat ze vermoedelijk geen goede weerspiegeling zijn van de realiteit, i.e. ofwel vermoedelijk inaccurate data of niet representatief (bijv. slechts geldig voor beperkte subset). R elevantie Gegeven de doelstelling van het onderzoek is het goed om je af te vragen of er wel een goede verantwoording (technisch noch functioneel) gevonden kan worden waarom deze variabele zou worden opgenomen. Hou hier best rekeneing met alle belanghebben zoals opdrachtgevers en eindgebruikers. 4.2 Stappen in data exploratie Elke exploratie is anders en iedereen heeft zo zijn eigen methode, maar als leidraad kan je deze stappen volgen: Zorg eerst dat je zo veel mogelijk begrijpt van de data nog vóór je in detail in de variabelen begint te duiken. Lees het codeboek of andere omschrijvingen. Vraag indien mogelijk hulp van iemand die al wel op de hoogte is Controleer of er tabellen, rijen of kolommen zijn die je niet nodig hebt voor jouw analyse en filter de overbodige data desgevallend weg zodat je hier ook geen tijd mee hoeft in te steken Begrijp wat één instantie (rij) hier precies voor staat en controleer of het aantal rijen dan ook logisch is Controleer nu pas de overblijvende data variabele-per-variabele Lees de omschrijving van de variabele en kijk naar een samenvatting of een willekeurige steekproef van de variabele Loop de DIPKEVER criteria één voor één af Beslis op basis hiervan of je de variabele wenst te houden (eng: keep) of te verwerpen (eng: drop) Maak korte notities Kijk naar de paarsgewijze correlaties (eng: pair-wise correlations) onder de variabelen 4.3 Voorbeeld data exploratie We gaan dit doen aan de hand van een voorbeeld (in R). Voorbeeld 4.1 Vraag: Sommige mensen zeggen dat er steeds méér terrorisme is in de wereld. Andere zeggen dat er altijd al terrorisme heeft bestaan. Wie heeft er gelijk? Antwoord: Via de bovenstaande link naar de standaard datasets vinden we twee datasets met het woordje terrorism in de titel. Ééntje heeft 206 rijen (nkill.byCountryYr), laten we die eens van naderbij bekijken: library(Ecdat) library(magrittr) ?terrorism Zorg er eerst voor dat je deze pakketten installeert (eenmalig) via install.packages of via de Packages-tab in RStudio. Als alles goed verlopen is, krijg je de documentatie te zien: We onderzoeken nu de documentatie en vinden dat de databank wel erg relevant en professioneel lijkt, maar niet zo up-to-date (1970 - 2015). Toch beslissen we om door te gaan met deze dataset. We lezen dat er eigenlijk drie datasets zijn, telkens met hun eigen structuur: terrorism: Jaartal × {verscheidene aantallen per type aanslag, locatie (wereld versus VS) en type slachtoffers} incidents.byCountryYr: Aantal aanslagen per {Land × Jaartal} nkill.byCountryYr: Aantal slachtoffers per {Land × Jaartal} Hierop lanceren we de vraag: Vraag terug: met méér terrorisme, bedoel je méér aanslagen of méér slachtoffers Stel dat de opdrachtgever het volgende antwoord geeft: Antwoord terug: méér aanslagen We kunnen nu zowel de eerste als de tweede gebruiken. We kiezen de eerste omdat daarin meer informatie vervat zit. We hebben die extra informatie nu niet nodig, maar misschien later wel. Één instantie (een rij) komt overeen met een jaartal. We zien onmiddellijk dat we de volgende variabelen nodig hebben uit de terrorism dataset: year: het jaar waarin de aanslag werd gepleegd, als natuurlijk getal, uniek voor elke rij incidents: het aantal aanslagen voor dat jaar wereldwijd dat &lt;- terrorism %&gt;% as.data.table %&gt;% extract(, .(year, incidents)) We overlopen de DIPKEVER criteria. De data zijn duidelijk en informatief. Ze lijken de privacy van niemand te schenden omdat het om geaggregeerde gegevens gaat, wereldwijd en telkens samengevat voor een heel kalenderjaar. Kwaliteit. We beginnen met de controle dat het jaartal en de incidenten als natuurlijke getallen worden behandeld. dat %&gt;% apply(2, class) ## year incidents ## &quot;numeric&quot; &quot;numeric&quot; numeric datatype in R stellen de reële getallen voor, niet natuurlijke getallen. Dat is geen ramp, natuurlijk, omdat \\(\\mathbb{N}\\subset\\mathbb{R}\\) maar kan soms problemen geven, laten we dit rechtzetten: dat[, year := year %&gt;% as.integer] dat[, incidents := incidents %&gt;% as.integer] dat %&gt;% apply(2, class) ## year incidents ## &quot;integer&quot; &quot;integer&quot; Nu controleren we of het jaartal inderdaad loopt van 1970 tot en met 2015: dat$year %&gt;% summary ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1970 1981 1992 1992 2004 2015 en we kunnen ook nakijken of het jaartal uniek is: dat$year %&gt;% duplicated %&gt;% any ## [1] FALSE De incidenten zijn ook natuurlijke getallen, maar van een andere soort dan het jaartal. De incidenten zijn namelijk ook aantallen en dit heeft heel wat statistische consequenties. Het betekent onder meer dat we voor deze variabele een histogram kunnen genereren: dat$incidents %&gt;% hist(main = &quot;Verdeling aantal aanslagen&quot;, xlab = &quot;# aanslagen per jaar&quot;, ylab = &quot;Frequentie&quot;) Hierin zien we dat er in het totaal meer dan 30 jaren zijn met minder dan 5000 aanslagen per jaar wereldwijd en dat er 3 jaren zijn met meer dan 10 000 aanslagen. Dit was de K van DIPKEVER, we zetten onze tocht voort. Over ethiek: voor velen is dit natuurlijk een gevoelig onderwerp maar het weergeven van de aantallen aanslagen kan moeilijk als aanstootgevend worden gezien. Bovendien worden hier nog geen voorspellingen gemaakt, dus dat lijkt in orde. Er ontbreken geen data (dus voorradig). Het consortium rond de Studie van Terrorisme en Responsen op Terrorisme (START) is verantwoordelijk voor de data en gezien hun staat van dienst en academische publicaties waaronder sommige in gerenommeerde tijdschriften, lijken ze op het eerste gezicht betrouwbaar (cfr. Echtheid). Tenslotte zijn de data ongetwijfeld relevant en daarmee slagen ze voor de volledige DIPKEVER test. Het onderlinge correleren van beide variabelen biedt hier geen meerwaarde. De exploratiefase is voorbij. Het volstaat ons nu om een grafiek op stellen waarbij het aantal aanslagen in de tijd wordt gevolgd: dat &lt;- dat[order(year)] void &lt;- dat[, plot(incidents ~ year, type = &quot;l&quot;, main = &quot;Verloop aantal aanslagen wereldwijd&quot;, xlab = &quot;Kalenderjaar&quot;, ylab = &quot;Aantal aanslagen per jaar&quot;)] Conclusie: Ja, het aantal gerapporteerde terroristische aanslagen lijkt volgens de START (Pape et al. 2014) toegenomen te zijn in de periode 2010 - 2015 ten opzichte van de periode 1970 - 2010. 4.4 Univariate verdelingen We zagen net hoe je met een eenvoudige opdracht een histogram kunt opstellen voor een variabele. Het histogram, geïntroduceerd in de paragraaf rond Soorten variabelen, geeft de verdeling weer van de waarden van één variabele (univariaat, eng: univariate) langsheen de meetschaal van de variabele. Dat is cruciale informatie. Één blik op de verdeling geeft antwoord op de volgende vragen: Wat is het datatype? Lijkt het een gekende theoretische verdeling te volgen? Heeft een duidelijke modus, meerdere modi? Lijkt het erop dat de data een natuurlijke oorsprong kennen of is de data mogelijk gemanipuleerd? Wat is de resolutie van de meting? Lijken er limieten te zijn waartussen de waarden zich bevinden Voorbeeld 4.2 Laten we de dataset rhDNase van naderbij onderzoeken met als doel om uitsluitend naar de verdelingen te kijken. We beginnen met het laden van de dataset en het tonen van de interne structuur (str) van het object dat de data bevat library(survival) data(rhDNase) rhDNase %&gt;% str ## &#39;data.frame&#39;: 767 obs. of 8 variables: ## $ id : int 1 2 3 4 5 6 7 8 9 10 ... ## $ inst : int 1 1 1 1 1 1 1 1 2 2 ... ## $ trt : int 1 1 0 1 0 1 0 0 1 0 ... ## $ entry.dt: Date, format: &quot;1992-03-20&quot; &quot;1992-03-24&quot; ... ## $ end.dt : Date, format: &quot;1992-09-04&quot; &quot;1992-09-09&quot; ... ## $ fev : num 28.8 64 67.2 57.6 57.6 25.6 86.4 32 86.4 28.8 ... ## $ ivstart : num NA NA 65 NA NA NA NA 90 NA 8 ... ## $ ivstop : num NA NA 75 NA NA NA NA 104 NA 22 ... We gaan nu één voor één de variabelen af: id: subject id. Is de identiteit en het heeft geen nut om hier een verdeling van de trekken. inst: enrolling institution. Dit is een integer, dus dat lijkt niet te kloppen, want we verwachten een organisatie hier. We behandelen het dan ook als categorische (nominale) variabele (factor in R) en maken een staafdiagram (eng: bar plot). Er is geen betekenisvolle sortering mogelijk bij categorische variabelen, maar het is een goed gewoonte om te toch even van frequent naar minder frequent te sorteren om een zicht te krijgen op de curve die zo ontstaat. rhDNase &lt;- rhDNase %&gt;% as.data.table rhDNase[, inst := inst %&gt;% factor] rhDNase$inst %&gt;% table %&gt;% sort %&gt;% rev %&gt;% barplot(xlab = &quot;Enrolling institution&quot;, ylab = &quot;# of instances&quot;, main = &quot;Distribution of the institutions&quot;, cex.names = .6, las = 2) Er zijn wel een aantal dominantere instituten maar die dominantie lijkt niet te extreem er blijft een goede verdeling tussen de verschillende instituten van grofweg 10-15 instanties per instituut. trt treatment arm: 0=placebo, 1= rhDNase Een arm betekent hier een vertakking van de beslissingsboom die gebruikt wordt om patiënten in een bepaalde categorie te plaatsen. Zulke een binaire kan je evengoed met een staafdiagram voorstellen, maar hier heb je duidelijk een controle experiment (de placebo-arm) en volstaat het om de verhouding behandeld/placebo mee te geven omdat alle informatie van de verdeling hierin vervat zit: rhDNase$trt %&gt;% sum %&gt;% divide_by(rhDNase %&gt;% nrow) %&gt;% multiply_by(100) %&gt;% sprintf(&quot;%.1f%%&quot;, .) ## [1] &quot;48.8%&quot; Dit ligt héél dicht bij 50% en we kunnen dus zeggen dat de groepen mooi gebalanceerd zijn zoals het hoort entry.dt: date of entry into the study. Uit de structuur zagen we al dat het formaat correct in ingesteld als datum. Een datum is in theorie een continue variabele omdat er tussen twee willekeurig gekozen tijdstippen oneindig veel nieuwe tijdstippen liggen. Bovendien heeft een datum geen betekenisvol nulpunt. Voor een continue variabele is een densiteit-diagram beter geschikt dan een histogram: rhDNase[, entry.dt.num := entry.dt %&gt;% as.numeric] rhDNase$entry.dt.num %&gt;% density %&gt;% plot(xaxt = &quot;n&quot;, main = &quot;Distribution of start dates &quot;, xlab = &quot;&quot;) axis(1, las = 2, cex = .8, at = rhDNase$entry.dt %&gt;% pretty, labels = rhDNase$entry.dt %&gt;% pretty) rhDNase$entry.dt.num %&gt;% rug Hier zien we dat de rekrutering van deelnemers voor de klinische studie na één maand op een laag pitje te hebben gestaan pas goed op gang is gekomen. De densiteit laat twee pieken zien (modi), we spreken van een bimodale verdeling. end.dt: date of last follow-up. Is sterk gelijkend op het vorige. Laten we deze feature gebruiken om de loopduur van elke instantie te berekenen en de distributie hiervan in grafiek te zetten (zie Oefening 4.1). Oefening 4.1 (Distributie-loopduur) Probeer de distributie voor de loopduur per instantie in beeld te brengen en te beschrijven wat je ziet. ivstart en ivstopdays from enrollment to the start of IV antibiotics en days from enrollment to the cessation of IV antibiotics (IV staat voor intraveneus) Deze laatste twee variabelen zijn weer verschillend: het gaat om discrete aantallen (\\(\\subset \\mathbb{N}\\)), dus geen kommagetallen, maar, tegen de verwachting, wél negatief kunnen zijn. Bovendien zijn er erg veel ontbrekende waarden: rhDNase$ivstart %&gt;% head(32) ## [1] NA NA 65 NA NA NA NA 90 NA 8 63 60 83 50 NA 99 35 71 NA 8 NA ## [22] NA NA 20 62 85 NA 13 51 166 37 65 rhDNase$ivstart %&gt;% is.na %&gt;% table ## . ## FALSE TRUE ## 367 400 We kunnen zelfs zeggen dat er voor ivstart meer gaten zijn dan kaas. We kunnen alsnog de verdeling onderzoeken van de overblijvende waarden: rhDNase$ivstart %&gt;% hist( main = &quot;Verdeling wachttijd voor behandeling&quot;, xlab = &quot;wachttijd&quot;, ylab = &quot;# instanties&quot;) abline(v = 0, lwd = 2) We zien een verdeling die eerder uniform is dan wel normaal. Ook hier kunnen we nu de verdeling van de behandelingsduur in grafiek zetten: par(mfrow = 1:2) rhDNase[, ivstop - ivstart] %&gt;% hist (main = &quot;Behandelingsduur&quot;) rhDNase[, ivstop - ivstart] %&gt;% log %&gt;% hist(main = &quot;ln(Behandelingsduur)&quot;) De eerste grafiek laat zien dat de behandelingsduur nogal rechtsscheef verdeeld is. De transformatie door middel van de natuurlijke logaritme (\\(ln(x)=\\,^elog(x)\\)) veranderd de verdeling in iets wat normaler lijkt. We zeggen dat de behandelingsduur lognormaal verdeeld lijkt te zijn. Laten we de theoretische curve erbij zetten om de afwijkingen tussen werkelijk en theoretisch te visualiseren: bduur_log &lt;- rhDNase[, log(ivstop - ivstart)] bduur_log &lt;- bduur_log[!is.na(bduur_log) &amp; !is.infinite(bduur_log)] bduur_log %&gt;% hist(main = &quot;ln(Behandelingsduur)&quot;, freq = FALSE, n = 20) x &lt;- (1:60 / 10) y &lt;- x %&gt;% dnorm( mean = bduur_log %&gt;% mean, sd = bduur_log %&gt;% sd) lines(x, y , col = 1, lwd = 3) We kunnen verdelingen ook met andere grafiek-types in beeld brengen. De meest populaire zijn de boxplot, de {dot plot}(https://en.wikipedia.org/wiki/Dot_plot_(statistics)), de beeswarm plot en de violin plot. Oefening 4.2 (Verdeling) Tracht de verdeling van de logaritmisch geschaalde behandelingsduur te visualiseren door middel van de functies base::dotchart, base::boxplot, beeswarm::beeswarm en vioplot::vioplot. De oplossing moet er zo uit zien: Eindresultaat grafieftypes Tip: Als je meer dan 300 karakters nodig hebt voor heel deze oefening, weet je dat je te ver aan het zoeken bent. Opgelet: de variabele bduur_log wordt voor deze oefening verwacht in scope te zijn. 4.5 Correlatie tussen twee variabelen Om correlatie te begrijpen simuleren we een bivariate verdeling met verschillende covariantie-matrices (zie figuur 4.1). library(MASS) library(latex2exp) copula &lt;- function(n, rho, mu1, mu2, sd1, sd2){ mu &lt;- c(mu1,mu2) sigma &lt;- matrix(c(sd1 ^ 2, sd1 * sd2 * rho, sd1 * sd2 * rho, sd2 ^ 2),2) mvrnorm(n, mu, sigma) %&gt;% as.data.table } par(mfrow = c(2, 2), mar = c(2, 3, 2, 1)) for(rho in c(.05, .33, .66, .95)){ dat &lt;- copula(1000, rho, 0, 0, 1, 1) dat %&gt;% plot (xlab = &quot;&quot;, ylab = &quot;&quot;, pch = 19, cex = .7, xlim = c(-3, 3), ylim = c(-3, 3)) text(-2.5, 2.7, TeX(sprintf(&quot;$\\\\rho = %.2f$&quot;, rho))) text(2, -2.7, TeX(sprintf(&quot;$\\\\hat{\\\\rho} = %.4f$&quot;, dat %&gt;% cor %&gt;% extract(1, 2)))) } Figuur 4.1: Demonstratie van de correlatie tussen twee variabelen. Merk op hoe de geschatte correlatie coëfficiënt de werkelijke benaderd. De covariantie matrix komt overeen met (\\(\\rho\\) is de correlatiecoëfficiënt) \\[\\begin{bmatrix}1 &amp; \\rho\\\\\\rho &amp; 1\\end{bmatrix}\\] Opmerking Opgelet: een correlatie tussen twee variabelen is geen garantie voor een causaal verband. Bekijk deze kennis-clip om te begrijpen hoe je wel een causaal verband kan onderzoeken: Oefening 4.3 (Wanneer corelleer) Gegeven de volgende combinaties van verschillende soorten variabelen, wanneer mag je wél correleren: Nominaal vs numeriek discreet lineair Numeriek continu lineair vs Numeriek continu lineair Nominaal vs numeriek continu circulair Numeriek continu lineair vs numeriek continu circulair Numeriek continu lineair vs ordinaal "],["manipuleren-van-data.html", "Hoofdstuk 5 Manipuleren van data 5.1 Kort overzicht van de manipulaties 5.2 (Eng.) Changing Category Names 5.3 (Eng.) Imputation 5.4 Onbehandeld", " Hoofdstuk 5 Manipuleren van data Leerdoel 5.1 Past de juiste principes toe tijdens het exploreren, hanteren en opkuisen van data (EA_LD758). Hieronder volgt een korte samenvatting van een aantal vaak gebruikte transformaties. Waarom zou je data willen transformeren. Hier staan een aantal redenen opgesomd: Om duidelijkheid te scheppen en de data leesbaarder te maken voor mensen Om de data voor te bereiden voor statische analyse Om nieuwe variabelen te creëren (eng: feature engineering) Om eenvoudiger gedistribueerd en parallel te kunnen programmeren Om de data te standaardiseren volgens CDMs (common data models) van het bedrijf (zoals voor een EDM Enterprise Data Model) of van een discipline (zoals CDISC standaarden in de klinische wereld) Om de data te onderworpen aan de regels van een bepaalde type opslag software. Wil je bijvoorbeeld de analyse dataset bewaren in een relationele databank, dan zal je rekening moeten houden met de regels rond primary, surrogate en foreign keys. 5.1 Kort overzicht van de manipulaties 5.1.1 Filteren en versnijden Het versnijden (eng: slicing) is hier te interpreteren in de betekenis van aan stukken van een bepaalde vorm snijden en niet bijvoorbeeld in de betekenis van aanmengen met iets van mindere kwaliteit. Het komt er op neer dat er een selectie van variabelen en instanties gemaakt wordt. Figuur 5.1: Schematisch overzicht van het versnijden van een dataset. Denk eraan dat het selecteren van van variabelen een courante activiteit is, terwijl het selecteren van instanties eerder zeldzaam is. Stelling 5.1 Het achterhouden of selecteren van variabelen, maar voornamelijke van instanties, kan vertrekkende gevolgen hebben. De datawetenschapper moet in het algemeen alle manipulaties maar filter-operaties in het bijzonder zoals het versnijden volledig en transparant rapporteren. Dus voorzichtig heid geboden. Maar in sommige gevallen is het verantwoord om ook instanties uit de dataset te filteren (eng: subsetting): De data bevat uitlopers die verantwoord kunnen worden of die zonder twijfel veroorzaakt worden door een foutieve invoer De combinatie van sommige variabelen voor een bepaalde instantie is heel waarschijnlijk foutief en is niet het gevolg van structurele maar eerder van eenmalig fouten in de dataset of het invoer-proces Een instantie bevat een combinatie van variabele waarden die de privacy van één of meerdere personen in het gedrang brengt Voorbeeld 5.1 (Versnijden van data) De wijn kwaliteit dataset bevat mogelijk outliers in de suikerwaarden, laten we dat eens nader bekijken. rode_wijn &lt;- fread(&quot;https://archive.ics.uci.edu/ml/machine-learning-databases/wine-quality/winequality-red.csv&quot;) rode_wijn[, `residual sugar`] %&gt;% density %&gt;% plot (main=&quot;Residual sugar (g/L)&quot;) Stel dat rode wijn met een suikergehalte boven de 10g/L wordt afgedaan als fruitsap, dan zou je er van uit mogen gaan dat er een aantal uitlopers zijn, zo halen we ze eruit: aantal_uitlopers &lt;- rode_wijn[`residual sugar` &gt; 10, .N] rode_wijn_echt &lt;- rode_wijn[`residual sugar` &lt; 10] rode_wijn_echt$`residual sugar` %&gt;% density %&gt;% plot (main=&quot;Residual sugar (g/L)&quot;, sub = paste(&quot;Excluding&quot;, aantal_uitlopers, &quot;&#39;outliers&#39; above 10g/L&quot;)) 5.1.2 Booleaans masker Een booleaans masker is gewoon een vector of lijst van booleaanse waarden die gebruikt kunnen worden om uit data frames en data tables die rijen te selecteren die overeenkomen met TRUE in het masker. In het Voorbeeld 5.1 werd er reeds van een masker gebruik gemaakt: rode_wijn[,`residual sugar` &lt; 10] %&gt;% head(50) ## [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [15] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [29] TRUE TRUE TRUE TRUE TRUE FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [43] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE 5.1.3 (Eng.) Grouping and Aggregation Upon Grouping the data table according to one or more features, the other variables need to be aggregated en this can be done using: Selection (first, last, second value, ) Measures of central tendency (mean, median, ) Measures of dispersion (variance, range, standard deviation, IQR, ) Extremes (min, max) Counts (Count, unique count, sum, majority vote, counts of missing values, ) 5.1.4 (Eng.) Transforming text Transformation Example Possible justification Change Encoding UTF16  UTF8 Avoid software incompatibilities Change Casing \"tfr523\"  \"TFR523\" Avoid confusing and allow for proper comparison Trim \" TFR523\"  \" TFR523\" Ensure proper identification &amp; comparison Add Leading zeroes \"653\", \"61\",   \"0653\", \"0061\",  Avoid str/num confusion by humans and machines Add prefix \"0653\"  \"UHR0653\" Avoid confusion with other IDs 5.1.5 (Eng.) Re-Scaling Numerical Values Here are some of the countless different types of re-scaling: Logarithm Logit-transform Normalization to a fixed maximum value Standardization (to a mean of 0 and a variance of 1) Division by another field (e.g. Quantity_By_Month / Days_Per_Month, Revenue_By_Store / Sold_By_Store, Quantity / Weight_Per_Unit, ) Multiplication (e.g. Quantity x Unit_Price, Quantity x Unit_Cost) Subtraction (e.g. Sales_value  Sales_cost) 5.1.6 (Eng.) Discretizations Is going from continuous data to more discrete data. Here are some examples: Rounding ([2.25, 2.35]  [2.2, 2.4]) Binning (here and here) Mind that discretization always leads to loss of information. 5.1.7 (Eng.) Information Content The information of a feature or an entire data set can be measured using indices such as the Shannon Entropy or the limiting density of discrete points. 5.1.8 (Eng.) Reformatting, Type Conversion, Casting or Coercion Examples: String to Integer or vice versa Reformatting date to ISO-8601 (\"07/04/2008  \"2007-07-04\" (YYYY-MM-DD)) 5.1.9 (Eng.) Changing numerical Values Far more invasive then re-scaling is when the data is changed based on some custom algorithm. An example hereof is the removal of a drift in the data (de-trending). Similarly, seasonal effects in time series data can be compensated away. Such changes can obviously impact the outcome of the analysis significantly and needs thorough justification. 5.2 (Eng.) Changing Category Names This is sometimes called recoding or refactorization and only affects nominal features. It serves to adhere to EDM, to the standards of the DWH and to ensure compatibility across data sets. Alternatively, it simply ensures that misspelled category names are being corrected and alternative spellings are being merged. 5.3 (Eng.) Imputation Imputation is the completion of missing data. Depending of the patterns the holes in the data display or on prior knowledge, separate techniques exist to fill in the blanks. 5.4 Onbehandeld De volgende onderwerpen werden niet behandeld, ik hoor het graag als jullie individueel of als groep hier meer over willen leren: Anonimiseren en pseudonimiseren "],["trainen-en-testen.html", "Hoofdstuk 6 Trainen en testen 6.1 Leren leven met de onzekerheid 6.2 Meten van de prestatie van een model 6.3 Training-, validatie- en test-set 6.4 Cross-validatie 6.5 Werkstroom deep learning 6.6 Data lekkage", " Hoofdstuk 6 Trainen en testen Leerdoel 6.1 Onderkent de basisprincipes van data training &amp; Cross-validatie (EA_LD754). Leerdoel 6.2 Herkent de risicos van onvolledige en inaccurate data (EA_LD759). Leerdoel 6.3 Gebruikt een diagnostische toolset om de performantie van ML modellen te meten (EA_LD760). Leerdoel 6.4 Evalueert op gepaste wijze de performantie van een algoritme. (EA_LD762). 6.1 Leren leven met de onzekerheid Misschien wel het belangrijkste aspect van ML is dat er nooit een garantie dat het gaat lukken. Vele mensen schijnen het hier erg moeilijk mee te hebben. Men zegt zegt al te vaak: We will be able to predict Waar voorzichtigheid hier op zijn plaats is: We hope to able to predict Dat betekent nog niet dat voorspellen onmogelijk is. We gaan ons best doen om, als er een patroon in de data verborgen zit, deze er ook uit te krijgen. Stelling 6.1 ML is geen toverkunst. Je kan nooit garanderen dat je een correcte voorspelling kan maken van iets wat nog niet geweten is. 6.2 Meten van de prestatie van een model Omdat we nooit zeker zijn dat ons model goed zal voorspellen, moeten we dus ons best doen om de prestaties zo hoog mogelijk te houden. En dat begint daar weer bij het meten van de prestaties. Maar hoe meet men de prestatie van een model? Uit de paragraaf Leren versus onthouden leerden we wat overfit is en wat het verschil is tussen regressie en ML. Hieruit volgt de Stelling 6.2. Stelling 6.2 De prestatie van een model wordt niet zomaar gemeten op basis van hoe goed het iets kan voorspellen. De prestatie van een model wordt in principe gemeten op basis van hoe goed het uitkomsten kan voorspellen gebruik maken van test-data, i.e. invoerdata waar noch het model, noch het leeralgoritme noch de datawetenschapper eerder mee in aanraking kwamen. 6.3 Training-, validatie- en test-set We begrijpen nu dat het trainen van een model en het testen van een model dient de gebeuren op afzonderlijke subsets van de data. Dus de oplossing is het opsplitsen van de data. De belangrijkste opsplitsing van data is die tussen de training-set en de test-set. De training set is de set van instanties (zie hoofdstuk over data als je deze term niet kent) waarmee het leeralgoritme getraind zal worden. De test-set krijgt het leeralgoritme niet te zien tot op het laatste, wanneer de prestaties van het model getest worden. Ook de datawetenschapper mag de test-set in principe niet zien en in professionele omgevingen wordt dit ook letterlijk genomen en is er een tussenpersoon tussen data leverancier en datawetenschapper die voor de opsplitsing zorgt. Er zijn verschillende manieren om de opsplitsing te verwezenlijken. Meestal krijgt men te maken met een randomisatie, dat is een opsplitsing op willekeurige basis, maar waarbij enkel de relatieve grootte van de training- en test-set worden meegegeven. In R: data(mtcars) set.seed(42) trn_msk &lt;- runif(nrow(mtcars)) &lt; .75 trn &lt;- mtcars[trn_msk, ] tst &lt;- mtcars[!trn_msk, ] cat(&quot;mtcars: &quot;, mtcars %&gt;% dim %&gt;% paste0(collapse = &quot; × &quot;), &quot;\\n&quot;) cat(&quot;trn: &quot;, trn %&gt;% dim %&gt;% paste0(collapse = &quot; × &quot;), &quot;\\n&quot;) cat(&quot;tst: &quot;, tst %&gt;% dim %&gt;% paste0(collapse = &quot; × &quot;), &quot;\\n&quot;) De variabele trn_msk heet zo omdat het om een Booleaanse masker (eng: mask; zie § Booleaans masker) gaat. In Python worden de features en de uitkomst (cfr. data) meestal gescheiden gehouden (om dan vaak terug samen te brengen met zip :-)) en wordt er een helper-functie uit de sklearn bibliotheek aangeroepen: from sklearn.model_selection import train_test_split from sklearn.datasets import load_wine X, y = load_wine(return_X_y=True) X_trn, X_tst, y_trn, y_tst = train_test_split( X, y, test_size = 0.25, random_state = 42) print(f&quot;X: {X.shape}&quot;) ## X: (178, 13) print(f&quot;y: {y.shape}&quot;) ## y: (178,) print(f&quot;X_trn: {X_trn.shape}&quot;) ## X_trn: (133, 13) print(f&quot;X_tst: {X_tst.shape}&quot;) ## X_tst: (45, 13) print(f&quot;X_trn: {y_trn.shape}&quot;) ## X_trn: (133,) print(f&quot;X_tst: {y_tst.shape}&quot;) ## X_tst: (45,) Het argument random_state in Python en de set.seed functie in R dienen om dit proces, dat inherent willekeurig is, toch reproduceerbaar te maken (zie § rond reproduceerbaarheid). Zie dit Wikipedia artikel om hier meer over te leren. Stelling 6.3 Regels rond de test set: De test-set blijft altijd verborgen voor het leeralgoritme De test-set blijft verborgen voor de datawetenschapper en het model tot helemaal op het einde wanneer de prestatie van het model word gemeten De test-set mag slechts één keer gebruikt worden, daarna is het gewoon data en mag het wel als training data gebruikt worden, maar mag het niet langer dienen om de prestatie van het model te meten Voor tijdsreeksen en geografische data wordt er zelden van randomisatie gebruik gemaakt. Dat heeft te maken van de autocorrelatie (zie § Tijd en ruimte). In plaats daarvan worden hier ofwel een bepaald gebied of bepaalde tijdspanne als test-set uitgekozen. Bijvoorbeeld, voor een tijdsreeks: library(forecast) USAccDeaths %&gt;% ets %&gt;% forecast(h = 48) %&gt;% plot(ylab = &quot;Monthly totals of accidental deaths in USA&quot;) abline(v = 1979, lty = 2) Figuur 6.1: Voorspelling van aantal Amerikaanse slachtoffers na 1979 (stippellijn). De grillige gekleurde lijn links van de stippellijn geeft het werkelijke aantal weer. De tegenhanger rechts van de stippellijn geeft de best mogelijke voorspelling weer na 1979. Het donkergrijze gebied geeft de 80%-predictie-interval weer en het lichtgrijze gebied de 90%-predictie interval. Dit type voorspelling-algoritmes (eng: forecasting algorythms) onderscheidt eerst de ruis (eng: error) van de trend en de periodiciteit (eng: seasonality), vandaar de naam ETS. (ANA) staat voor respectievelijk aan additieve ruis, geen trend (N van No) en een additieve periodiciteit. Naast een training-set en een test set, bestaat er nog zoiets als een validatie set. In één van de latere paragrafen binnen dit hoofdstuk gaan we zien dat er zoiets als hyperparameters bestaan die het verloop van het ML proces mee helpen bepalen. Vaak moeten die hyperparaneters ook nog eerst geoptimaliseerd worden en hiervoor wordt soms een afzonderlijke set, namelijk de validatie set aangewend. Een andere reden om de validatie-set te gebruiken in gewoon om dienst te doen als tijdelijke test-set (omdat we de echte test-set naturlijk maar één keer kunnen aanwenden). Let wel: die opsplitsing in verscheidene subsets zijn niet in steen gebeiteld en kunnen geval-per-geval bekeken worden op basis van de hoeveelheid beschikbare data, het type algoritme, enz. Het zelfde geldt trouwens voor hoeveel percent van de data naar welke subset moet gaan. Er wordt soms de gulden regel : gebruikt voor de verdeling tussen training- en test-set, maar ook dit hoeft niet vast te liggen. Hoe meer data wordt vrijgehouden om te testen hoe dichter de gemeten prestatie bij de werkelijke prestatie (op een grotere groep nieuwe data, wanneer het algoritme in productie staat) zal aanleunen. Maar hoe meer test-data, hoe minder training-data en wat is het nut om super-precies te prestatie te kunnen meten van een barslecht model. 6.4 Cross-validatie Dit ideale scenario kan niet altijd gehanteerd worden en daarom laat men een aantal vormen van contact met de test data toe: Stelling 6.4 Alvorens de finale bekendmaking van de prestatie van het model kan men doen alsof we met ongeziene data werken door middel van cross-validatie. Het principe is eenvoudig, telkens laat je een deel van de training-set (test-fold) weg en train je een model op het overblijvend deel (training fold). Je kan nu de prestatie \\(\\varepsilon_i\\) meten om het weggelaten deel te voorspellen. Daarna voeg je de test-fold weer bij de rest en ga je voort met het volgende deel (6.2). In het voorbeeld worden de scores van de folds uitgemiddeld, maar je kan hier ook kiezen om de beste te nemen (bijvoorbeeld met de kleinste fout) of nog een andere vorm van aggregatie toepassen. Figuur 6.2: )cross-validatie voorbeeld. Een dataset met dimensies \\(9\\times3\\) wordt eerst op gesplitst in een training set van \\(\\frac23\\) en een test set van \\(\\frac13\\). Van de training set wordt telkens \\(\\frac16\\) opzij gehouden als test fold. De resultaten van de validaties van elke fold \\(\\varepsilon_i\\) worden geaggregeerd in \\(\\varepsilon_{cv}\\) door het gemiddelde te nemen. Pas op het einde van dit proces wordt eenmalig de finale prestatie \\(\\varepsilon_{final}\\) berekend. Figuur 6.3: )Een model voorbeeld van hoe een cross-validatie strategie past binnen een begeleid ML proces. 6.5 Werkstroom deep learning Figuur 6.4 vat samen hoe de werkstroom van een ANN eruit ziet. Het is een complex schema maar desalniettemin erg belangrijk. Dankzij deze werkstroom weten we hoe lang we moeten blijven trainen, i.e. hoeveel epoch we moeten doorlopen alvorens we kunnen stoppen. Het begint met het verzamelen van gegevens. Op basis van de structuur van de gegevens ontwerpen we de architectuur van ons neuraal netwerk. De data wordt ondertussen gesplitst in een training-, validatie- en test-set (zie betrokken paragraaf voor meer info). We gaan eerst aan de slag met met de training-set. Na de eerste epoch eindigen we met een tijdelijke versie van het ANN model. Indien de restterm verkleint controleren we of dit tijdelijk model ook beter presteert op de validatie-set. Indien zo is, gaan we naar de volgende epoch. Deze lus houden we aan totdat de prestatie van het tijdelijk model niet meer verbetert. Er gaat een punt komen waarop de prestatie nog wél verbetert voor de training-set, maar niet voor de validatie-set. Dat is het punt waarop het tijdelijk model begint te overfitten. Als dat gebeurt, moet de architectuur van het ANN worden aangepast om de overfitting tegen te werken. Dit kan onder andere gebeuren door een aantal minder belangrijke verbindingen tussen de neuronen te verbreken (zie later). Op een gegeven ogenblik zal natuurlijk ook de fit op de training set niet verbeterd kunnen worden, je kan natuurlijk niet oneindig lang verbeteren. Dit is het punt waarop men niet enkel naar de relatieve prestatie moet kijken (beter versus slechter), maar ook naar de absolute prestatie van het tijdelijk model. Pas wanneer het tijdelijk model op de training-set slaagt voor een aantal voorgedefinieerde criteria, mag er finaal (en dus slechts eenmalig) getest worden op de test-set. In normale omstandigheden worden de criteria op de test-set (mede-)gestuurd door uitwendige factoren (zie paragraaf rond Uitwendige invloed). Slaagt het model niet, dan zit er niets anders op om nieuwe data te zoeken. De test-set is nu a.h.w. gecompromitteerd (eng: compromised) en mag niet meer in die hoedanigheid functioneren. Figuur 6.4: De typische werkstroom voor het afhandelen van deep-learning ANN. Meer uitleg in de tekst. Gebaseerd op de werkstroom in figuur 2-14 van Buduma and Locascio 2017. 6.6 Data lekkage In de paragraaf Leren versus onthouden en inferentie zagen we dat leren per definitie betekent dat er iets nieuw wordt aangeleerd. Een van de vele gevaren van ML is dan ook dat er iets wordt aangeleerd wat je al wist. Data lekkage (eng: data leackage) is een ernstig probleem dat soms ongezien zijn weg baant in een ML algoritme en dat voor onrealistisch hoge performantie leidt. Stelling 6.5 Data lekkage wordt veroorzaakt wanneer informatie afkomstig van de test data gebruikt wordt om het leeralgoritme mee te trainen. We gaan het probleem onderzoeken aan de hand van twee voorbeelden: Voorbeeld 6.1 Voorspellen van slaagcijfers: stel dat je gevraagd wordt om, op basis van onderstaande data, de slaagcijfers van de studenten te voorspellen. Welke variabelen mag je dan, gegeven bovenstaande definitie, wel gebruiken voor de voorspelling te doen en welke niet. Student Year Semester Course Study_Time_Std Exam_Feedback_Length Exam_Score A 2018 1 Statistics .342 213 10 A 2018 2 Informatics .612 76 14 B 2018 1 Statistics .771 0 5       "],["bronvermelding.html", "Bronvermelding", " Bronvermelding Abu-Mostafa, Y.S., Magdon-Ismail, M., Lin, H.-T., 2012. Learning from data. AMLBook New York, NY, USA: Buduma, N., Locascio, N., 2017. Fundamentals of deep learning: Designing next-generation machine intelligence algorithms. \" OReilly Media, Inc.\". Henderson, H.V., Velleman, P.F., 1981. Building multiple regression models interactively. Biometrics 391411. Hermans, M., 2019. Show &amp;amp; tell: Making thematic maps in r [WWW Document] [Online; accessed 2020-09-05]. https://doi.org/10.5281/ZENODO.4014809 Li, C., 2017. Improve rs performance using JuliaCall with mandelbrot set example [WWW Document] [Online; accessed 2020-09-14]. URL https://github.com/Non-Contradiction/JuliaCall/tree/master/example/mandelbrot Mayfield, F., 2007. Image of iris virginica shrevei at the james woodworth prairie preserve - a bud and a single flower at full bloom [WWW Document] [Online; accessed 2020-09-07]. URL https://commons.wikimedia.org/wiki/File:Iris_virginica.jpg Mayfield, F., 2005. Blue flag flower close-up (iris versicolor) at the forillon national park of canada [WWW Document] [Online; accessed 2020-09-07]. URL https://commons.wikimedia.org/wiki/File:Iris_versicolor_3.jpg Nelder, J., 1965. A. &amp; mead, r.(1965). The Computer Journal 7, 13. Pape, R., Ruby, K., Bauer, V., Jenkins, G., 2014. How to fix the flaws in the global terrorism database and why it matters. The Washington Post. Shazeer, N., Mirhoseini, A., Maziarz, K., Davis, A., Le, Q., Hinton, G., Dean, J., 2017. Outrageously large neural networks: The sparsely-gated mixture-of-experts layer. arXiv preprint arXiv:1701.06538. Szczecinkowaty, K., 2007. Image of iris setosa in botanical garden in pozna [WWW Document] [Online; accessed 2020-09-07]. URL https://commons.wikimedia.org/wiki/File:Kosaciec_szczecinkowaty_Iris_setosa.jpg "]]
